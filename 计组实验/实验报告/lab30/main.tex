%!TeX program = xelatex
\documentclass[12pt,hyperref,a4paper,UTF8]{ctexart}
\usepackage{zjureport}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{float}
\usepackage{xcolor}
% \lstset{
%     %backgroundcolor=\color{red!50!green!50!blue!50},%代码块背景色为浅灰色
%     rulesepcolor= \color{gray}, %代码块边框颜色
%     breaklines=true,  %代码过长则换行
%     numbers=left, %行号在左侧显示
%     numberstyle= \small,%行号字体
%     keywordstyle= \color{blue},%关键字颜色
%     commentstyle=\color{gray}, %注释颜色
%     frame=shadowbox%用方框框住代码块
%     basicstyle=\small\ttfamily % 设置代码块的基本字体样式
%     }
\lstdefinestyle{verilog-style}{
    language=Verilog,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\lstset{style=verilog-style}

%%-------------------------------正文开始---------------------------%%
\begin{document}

%%-----------------------封面--------------------%%
\cover

%%------------------摘要-------------%%
%\begin{abstract}
%
%在此填写摘要内容
%
%\end{abstract}

\thispagestyle{empty} % 首页不显示页码

%%--------------------------目录页------------------------%%
\newpage
\tableofcontents

%%------------------------正文页从这里开始-------------------%
\newpage

%%可选择这里也放一个标题
%\begin{center}
%    \title{ \Huge \textbf{{标题}}}
%\end{center}

\section{实验目的}
\begin{enumerate}
  \item 熟悉 RISC-V 指令系统。
  \item 了解提高 CPU 性能的方法。
  \item 掌握流水线 RISC-V 微处理器的工作原理。
  \item 理解数据冒险、控制冒险的概念以及流水线冲突的解决方法。
  \item 掌握流水线 RISC-V 微处理器的测试方法。
  \item 了解用软件实现数字系统的方法。
\end{enumerate}



\section{实验任务与要求}
\subsection*{基本要求}

设计一个流水线 RISC-V 微处理器，具体要求如下所述。

\begin{enumerate}
    \item 至少运行下列 RV32I 核心指令。
    \begin{enumerate}
        \item 算术运算指令：add, sub, addi
        \item 逻辑运算指令：and, or, xor, slt, sltu, andi, ori, xori, slti, sltiu
        \item 移位指令：sll, srl, sra, slli, srli, srai
        \item 条件分支指令：beq, bne, blt, bge, bltu, bgeu
        \item 无条件跳转指令：jal, jalr
        \item 数据传送指令：lw, sw, lui, auipc
        \item 空指令：nop
    \end{enumerate}
    \item 采用 5 级流水线技术，对数据冒险实现转发或阻塞功能。
    \item 在 Nexys Video 开发系统中实现 RISC-V 微处理器，要求 CPU 的运行速度大于 25MHz。
\end{enumerate}

\subsection*{扩展要求}

\begin{enumerate}
    \item 要求设计的微处理器还能运行 lb, lh, lhu, lbu, lhu, lwu, sb, sh 或 sd 等字节、半字和双字数据传送指令。
    \item 要求设计的 CPU 增加异常（exception）、自陷（trap）、中断（interrupt）等处理方案。
\end{enumerate}


\section{实验设备}

\begin{enumerate}
    \item 装有 Vivado 和 ModelSim SE 软件的计算机。
    \item Nexys Video 开发板一套。
    \item 带有 HDMI 接口的显示器一台。
\end{enumerate}

\section{实验内容}

\begin{enumerate}
    \item 从网络下载相关文件。
    \item 编写指令译码单元Decode模块的Verilog HDL代码，并用ModelSim进行功能仿真。
    \item 编写寄存器堆Register模块的Verilog HDL代码。
    \item 编写ID模块Verilog HDL代码，ID.v文件已给端口列表。
    \item 编写ALU模块的Verilog HDL代码并用ModelSim进行功能仿真。
    \item 编写执行单元EX模块的Verilog HDL代码，EX.v文件已给端口列表。
    \item 编写IF模块的Verilog HDL代码并用ModelSim进行功能仿真。
    \item 打开Vivado文件夹下的Risc5CPU.xpr工程，生成符合CPU要求的数据存储器IP内核。
    \item 编写CPU顶层的Verilog HDL代码，并用ModelSim进行功能仿真。注意：由于存在IP内核，仿真时，需加仿真库，方法参考实验3.根据表30.11验证仿真结果。表格中显示的数据均为十六进制，表格中“-”表示此处值无意义。
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fig/image1.png}
    \caption{仿真结果验证表格}
\end{figure}
    \item 再次打开 Vivado 文件夹下的 Risc5CPU.xpr 工程，添加流水线 CPU 设计的全部代码，然后综合、实现和下载至 Nexys Video 开发板。
    \item 连接带有 HDMI 接口的显示器，进行测试。首先将 SW0 置于低电平，使 RISC-V CPU 工作在“单步”运行模式。复位后，每按一下上边按键，RISC-V CPU 运行一步，记录下显示器上的结果，对照表 30.11 验证设计是否正确。



\end{enumerate}




\newpage

\section{实验过程与结果}

\subsection{Decode子模块}


\subsubsection*{\Large 设计原理}
\normalsize

  Decode模块包括译码部分，主要功能是对指令进行译码，将指令的操作码和立即数提取出来，
  还包括ALUcode的生成，用于ALU模块的控制和立即数产生电路的设计，其设计原理如下所示。

  RISC-V 将指令分为 R\_type、I\_type、S\_type、U\_type、SB\_type、U\_type 等六类。
  从电路设计角度看，根据操作数的来源和立即数构成方式不同，再次细分指令如下。

\begin{itemize}
    \item R\_type 类：操作码（opcode，简称 op）为 7'h33，R 类的所有指令，两个操作数分别为 rs1 和 rs2；
    \item I\_type 类：操作码 7'h13，I 类的算术逻辑运算指令和移位指令，两个操作数分别为 rs1 和立即数 imm；
    \item LW 指令：操作码 7'h03，I 类的数据传送指令 lw，两个操作数分别为 rs1 和立即数 imm；
    \item JALR 指令：操作码 7'h67，I 类的无条件分支指令 jalr，两个操作数分别为 PC 和常数 4；
    \item SW 指令：操作码 7'h23，S 类的数据传送指令 sw，两个操作数分别为 rs1 和立即数 imm；
    \item SB\_type 类：操作码 7'h63，SB 类的所有指令，两个操作数分别为 PC 和立即数 imm；
    \item LUI 指令：操作码 7'h37，U 类的数据传送指令 lui，只有一个操作数（立即数 imm）；
    \item AUIPC 指令：操作码 7'h17，U 类的数据传送指令 auipc，两个操作数分别为 PC 和立即数 imm；
    \item JAL 指令：操作码 7'h6f，U 类的无条件分支指令 jal，两个操作数分别为 PC 和常数 4。
\end{itemize}

\textbf{因此，设置 R\_type、I\_type、SB\_type、LW、JALR、SW、LUI、AUIPC 和 JAL 等变量来表示指令类型，各变量的值由下式决定。}

\begin{equation*}
\begin{aligned}
R\_type &= (op == R\_type\_op) \\
I\_type &= (op == I\_type\_op) \\
SB\_type &= (op == SB\_type\_op) \\
LW &= (op == LW\_op) \\
JALR &= (op == JALR\_op) \\
SW &= (op == SW\_op) \\
LUI &= (op == LUI\_op) \\
AUIPC &= (op == AUIPC\_op) \\
JAL &= (op == JAL\_op)
\end{aligned}
\end{equation*}

\begin{enumerate}
    \item 只有 LW 指令读取存储器且回写数据取自存储器，所以有
    \begin{equation}
    MemtoRead = LW 
    \end{equation}
    \begin{equation}
    MemRead = LW \
    \end{equation}
    \item 只有 SW 指令会对存储器写数据，所以有
    \begin{equation}
    MemWrite = SW 
    \end{equation}
    \item 需要进行回写的指令类型有 R\_type、I\_type、LW、JALR、LUI、AUIPC 和 JAL。所以有
    \begin{equation}
    RegWrite = R\_type || I\_type || LW || JALR || LUI || AUIPC || JAL 
    \end{equation}
    \item 只有 JALR 和 JAL 两条无条件分支指令，所以有
    \begin{equation}
    Jump = JALR || JAL 
    \end{equation}
    \item 操作数 A 和 B 的选择信号的确定

    分析各类指令，可得到表 30.4 操作数选择的功能表。

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image2.png}
    \end{figure}

    从上表可获得 ALUSrcA\_id 和 ALUSrcB\_id[1:0] 表达式mm
    \begin{align}
    ALUSrcA &= JALR \ || \ JAL \ || \ AUIPC  \\
    ALUSrcB[1] &= JAL \ || \ JALR  \\
    ALUSrcB[0] &=  \sim(R\_type \ || \ JAL \ || \ JALR)
    \end{align}

    \item ALmmUCode 的确定
    
    除了条件分支指令，其它指令都需要 ALU 执行运算，共有 11 种不同运算，ALUCode 信号需用 4 位二进制表示。
    最主要为加法运算，设为默认算法，ALUCode 的功能表如下 所示。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image3.png}
    \end{figure}

   \item 立即数产生电路 (ImmGen) 设计
   
    L\_type、SB\_type、LW、JALR、SW、LUI、AUIPC 和 JAL 这几类指令均用到立即数。
    由于 L\_type 的算术逻辑运算与移位运算指令的立即数构成方法不同，这里再设定一个变量 Shift 来区分两者。
    Shift=1 表示移位运算，否则则算术逻辑运算。Shift 值由式 (30.11) 计算。
    \begin{equation}
    Shift=(funct3==1) \ || \ (funct3==5)
    \end{equation}

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image4.png}
    \end{figure}
\end{enumerate}

\subsubsection*
{\Large Verilog HDL代码与设计分析}
\normalsize


下面的代码是Decode模块的输入输出信号和参数，掩码的设置，以及指令类型变量的定义等内容

\begin{lstlisting}[language=Verilog,caption=Decode模块定义]
module Decode(   
	// Outputs
	MemtoReg, RegWrite, MemWrite, MemRead,ALUCode,ALUSrcA,ALUSrcB,Jump,JALR,Imm,offset,
	// Inputs 
    Instruction);
	input [31:0]	Instruction;	// current instruction
    //输出信号定义
	output		   MemtoReg;		// use memory output as data to write into register
	output		   RegWrite;		// enable writing back to the register
	output		   MemWrite;		// write to memory
	output         MemRead;
	output [3:0]   ALUCode;         // ALU operation select
	output      	ALUSrcA;
	output [1:0]   ALUSrcB;
	output         Jump;
	output         JALR;
	output[31:0]   Imm,offset;
	
//*********************
//  instruction type decode
//**********************
	parameter  R_type_op=   7'b0110011;
	parameter  I_type_op=   7'b0010011;
	parameter  SB_type_op=  7'b1100011;
	parameter  LW_op=       7'b0000011;
	parameter  JALR_op=     7'b1100111;
	parameter  SW_op=       7'b0100011;
	parameter  LUI_op=      7'b0110111;
	parameter  AUIPC_op=    7'b0010111;	
	parameter  JAL_op=      7'b1101111;	
//
  //
   parameter  ADD_funct3 =     3'b000 ;
   parameter  SUB_funct3 =     3'b000 ;
   parameter  SLL_funct3 =     3'b001 ;
   parameter  SLT_funct3 =     3'b010 ;
   parameter  SLTU_funct3 =    3'b011 ;
   parameter  XOR_funct3 =     3'b100 ;
   parameter  SRL_funct3 =     3'b101 ;
   parameter  SRA_funct3 =     3'b101 ;
   parameter  OR_funct3 =      3'b110 ;
   parameter  AND_funct3 =     3'b111;
   //
   parameter  ADDI_funct3 =     3'b000 ;
   parameter  SLLI_funct3 =     3'b001 ;
   parameter  SLTI_funct3 =     3'b010 ;
   parameter  SLTIU_funct3 =    3'b011 ;
   parameter  XORI_funct3 =     3'b100 ;
   parameter  SRLI_funct3 =     3'b101 ;
   parameter  SRAI_funct3 =     3'b101 ;
   parameter  ORI_funct3 =      3'b101 ;
   parameter  ANDI_funct3 =     3'b111;
   //
   parameter	 alu_add=  4'b0000;
   parameter	 alu_sub=  4'b0001;
   parameter	 alu_lui=  4'b0010;
   parameter	 alu_and=  4'b0011;
   parameter	 alu_xor=  4'b0100;
   parameter	 alu_or =  4'b0101;
   parameter 	 alu_sll=  4'b0110;
   parameter	 alu_srl=  4'b0111;
   parameter	 alu_sra=  4'b1000;
   parameter	 alu_slt=  4'b1001;
   parameter	 alu_sltu= 4'b1010; 
\end{lstlisting}

下面的代码根据上述的设计原理，实现了各种输出信号的设置，以及对指令的译码
\begin{enumerate}
    \item \textbf{指令字段}：
    \begin{itemize}
        \item 定义了指令的操作码 \texttt{op}、功能码 \texttt{funct6\_7} 和 \texttt{funct3}。
        \item 通过对 \texttt{Instruction} 信号的位切片，分别获取操作码和功能码。
    \end{itemize}

    \item \textbf{指令类型译码}：
    \begin{itemize}
        \item 定义了多个信号来表示不同类型的指令，如 \texttt{R\_type}、\texttt{I\_type}、\texttt{SB\_type} 等。
        \item 通过比较操作码 \texttt{op}，确定当前指令的类型。
    \end{itemize}

    \item \textbf{内存和寄存器操作信号}：
    \begin{itemize}
        \item \texttt{MemtoReg} 和 \texttt{MemRead} 信号在 \texttt{LW} 指令时有效，表示从内存读取数据并写回寄存器。
        \item \texttt{MemWrite} 信号在 \texttt{SW} 指令时有效，表示写数据到内存。
        \item \texttt{RegWrite} 信号在需要写回寄存器的指令时有效，如 \texttt{R\_type}、\texttt{I\_type}、\texttt{LW} 等。
    \end{itemize}

    \item \textbf{跳转信号}：
    \begin{itemize}
        \item \texttt{Jump} 信号在无条件跳转指令 \texttt{JAL} 和 \texttt{JALR} 时有效。
    \end{itemize}

    \item \textbf{ALU操作数选择信号}：
    \begin{itemize}
        \item \texttt{ALUSrcA} 信号在 \texttt{JALR}、\texttt{JAL} 和 \texttt{AUIPC} 指令时有效。
        \item \texttt{ALUSrcB} 信号根据指令类型选择不同的操作数。
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Verilog,caption=信号设置]
//******************
// instruction field
//******************
	wire [6:0]		op;
	wire  	 	    funct6_7;
	wire [2:0]		funct3;
	assign op			= Instruction[6:0];
	assign funct6_7		= Instruction[30];
 	assign funct3		= Instruction[14:12];
	
  // 指令译码,获得对应的指令类型
  wire R_type, I_type, SB_type, LW, SW, LUI, AUIPC, JAL;
  assign R_type = (op == R_type_op);
  assign I_type = (op == I_type_op);
  assign SB_type = (op == SB_type_op);
  assign LW = (op == LW_op);
  assign JALR = (op == JALR_op);
  assign SW = (op == SW_op);
  assign LUI = (op == LUI_op);
  assign AUIPC = (op == AUIPC_op);
  assign JAL = (op == JAL_op);
  //只有LW读取内存写回寄存器
  assign MemtoReg = LW;
  assign MemRead = LW;
  //只有SW写内存
  assign MemWrite = SW;
  //需要写回的指令
  assign RegWrite = R_type || I_type || LW || JALR || LUI || AUIPC || JAL;
  //无条件跳转
  assign Jump = JAL || JALR;
  //ALU操作数
  assign ALUSrcA = JALR || JAL || AUIPC;
  assign ALUSrcB[1]=JAL || JALR;
  assign ALUSrcB[0]=~(R_type || JAL || JALR);
\end{lstlisting}


这部分代码实现了对ALU操作码的确定。具体分析如下：

\begin{enumerate}
    \item \textbf{定义和初始化}：
    \begin{itemize}
        \item 使用 \texttt{reg [3:0] ALUCode\_temp} 定义一个4位的寄存器 \texttt{ALUCode\_temp}，用于存储临时的ALU操作码。
    \end{itemize}

    \item \textbf{组合逻辑块}：
    \begin{itemize}
        \item 使用 \texttt{always @(*)} 块定义组合逻辑，确保在输入信号变化时重新计算ALU操作码。
    \end{itemize}

    \item \textbf{casez语句}：
    \begin{itemize}
        \item 使用 \texttt{casez} 语句对输入信号 \texttt{\{R\_type, I\_type, LUI, funct3, funct6\_7\}} 进行模式匹配。
        \item 根据前文中ALUcode的真值表，根据不同的输入组合，设置 \texttt{ALUCode\_temp} 的值。例如：
        \begin{itemize}
            \item \texttt{7'b100\_000\_0} 对应 \texttt{ADD} 操作，设置 \texttt{ALUCode\_temp = 4'd0}。
            \item \texttt{7'b100\_000\_1} 对应 \texttt{SUB} 操作，设置 \texttt{ALUCode\_temp = 4'd1}。
            \item 其他操作码如 \texttt{XOR}、\texttt{OR}、\texttt{AND} 等也分别对应不同的 \texttt{ALUCode\_temp} 值。
        \end{itemize}
    \end{itemize}

    \item \textbf{默认值}：
    \begin{itemize}
        \item \texttt{default} 分支设置默认的ALU操作码为 \texttt{4'd0}，即 \texttt{ADD} 操作。
    \end{itemize}

    \item \textbf{输出赋值}：
    \begin{itemize}
        \item 最后，将 \texttt{ALUCode\_temp} 的值赋给输出信号 \texttt{ALUCode}。
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Verilog,caption=ALUcode确定]
  //ALU操作码
  reg [3:0] ALUCode_temp;
  always @(*) begin
      casez ({R_type,I_type,LUI,funct3,funct6_7})
          7'b100_000_0: ALUCode_temp = 4'd0; //ADD
          7'b100_000_1: ALUCode_temp = 4'd1; //SUB
          7'b100_001_0: ALUCode_temp = 4'd6; //left shift
          7'b100_010_0: ALUCode_temp = 4'd9; //set signcompare less than
          7'b100_011_0: ALUCode_temp = 4'd10; //set unsigncompare less than
          7'b100_100_0: ALUCode_temp = 4'd4; //XOR
          7'b100_101_0: ALUCode_temp = 4'd7; //right shift
          7'b100_101_1: ALUCode_temp = 4'd8; //arithmetic right shift
          7'b100_110_0: ALUCode_temp = 4'd5; //OR
          7'b100_111_0: ALUCode_temp = 4'd3; //AND
          7'b010_000_?: ALUCode_temp = 4'd0; //ADDI
          7'b010_001_?: ALUCode_temp = 4'd6; //left shift immediate
          7'b010_010_?: ALUCode_temp = 4'd9; //set signcompare less than immediate
          7'b010_011_?: ALUCode_temp = 4'd10; //set unsigncompare less than immediate
          7'b010_100_?: ALUCode_temp = 4'd4; //XOR immediate
          7'b010_101_0: ALUCode_temp = 4'd7; //right shift immediate
          7'b010_101_1: ALUCode_temp = 4'd8; //arithmetic right shift immediate
          7'b010_110_?: ALUCode_temp = 4'd5; //OR immediate
          7'b010_111_?: ALUCode_temp = 4'd3; //AND immediate
          7'b001_???_?: ALUCode_temp = 4'd2; //ALUResult=B
          default: ALUCode_temp = 4'd0; //ADD
      endcase
  end
  assign ALUCode = ALUCode_temp;
\end{lstlisting}

这部分代码实现了对立即数的生成。具体分析如下：

\begin{lstlisting}[language=Verilog,caption=立即数]
  //立即数
  //设置Shift信号
  wire Shift;
  assign Shift=(funct3==3'b001)||(funct3==3'b101);

  reg [31:0] Imm_temp,offset_temp;
  //Imm
  always @(*) begin
    if (I_type==1 && Shift==1)begin
      Imm_temp = { 27'd0, Instruction[24:20] }; //shift
    end
    else if (I_type==1 && Shift==0)begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:20] };//immediate
    end
    else if (LW==1) begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:20] };//load
    end
    else if (SW==1)begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:25], Instruction[11:7] }; //store
    end
    else if (LUI==1)begin
      Imm_temp = { Instruction[31:12], 12'd0 }; //LUI
    end
    else if (AUIPC==1)begin
      Imm_temp = { Instruction[31:12], 12'd0 }; //AUIPC
    end
    else begin
      Imm_temp = 32'b0;//default
    end
  end
  //offset
  always @(*) begin
    if (JALR==1) begin
      offset_temp = { {20{Instruction[31]}}, Instruction[31:20] };//JALR
    end
    else if (JAL==1) begin
      offset_temp = { {11{Instruction[31]}}, Instruction[31], Instruction[19:12], Instruction[20], Instruction[30:21], 1'b0 };//JAL
    end
    else if (SB_type==1) begin
      offset_temp = { {19{Instruction[31]}}, Instruction[31], Instruction[7], Instruction[30:25], Instruction[11:8], 1'b0 };//SB
    end
    else begin
      offset_temp = 32'b0;//default
    end
  end
  assign Imm=Imm_temp;
  assign offset=
\end{lstlisting}

\begin{enumerate}
    \item \textbf{Shift信号}：
    \begin{itemize}
        \item 定义了一个 \texttt{Shift} 信号，用于区分移位指令和其他指令。
        \item 当 \texttt{funct3} 为 \texttt{3'b001} 或 \texttt{3'b101} 时，\texttt{Shift} 信号为高。
    \end{itemize}

    \item \textbf{立即数生成}：
    \begin{itemize}
        \item 使用 \texttt{always @(*)} 块，根据指令类型和 \texttt{Shift} 信号生成立即数 \texttt{Imm\_temp}。
        \item 对于不同类型的指令，生成相应的立即数。例如：
        \begin{itemize}
            \item 对于移位指令，立即数为 \texttt{Instruction[24:20]}。
            \item 对于其他I型指令，立即数为 \texttt{Instruction[31:20]}。
            \item 对于LW指令，立即数为 \texttt{Instruction[31:20]}。
            \item 对于SW指令，立即数为 \texttt{Instruction[31:25], Instruction[11:7]}。
            \item 对于LUI和AUIPC指令，立即数为 \texttt{Instruction[31:12]}。
        \end{itemize}
    \end{itemize}

    \item \textbf{偏移量生成}：
    \begin{itemize}
        \item 使用 \texttt{always @(*)} 块，根据指令类型生成偏移量 \texttt{offset\_temp}。
        \item 对于不同类型的跳转和分支指令，生成相应的偏移量。例如：
        \begin{itemize}
            \item 对于JALR指令，偏移量为 \texttt{Instruction[31:20]}。
            \item 对于JAL指令，偏移量为 \texttt{Instruction[31], Instruction[19:12], Instruction[20], Instruction[30:21]}。
            \item 对于SB型指令，偏移量为 \texttt{Instruction[31], Instruction[7], Instruction[30:25], Instruction[11:8]}。
        \end{itemize}
    \end{itemize}

    \item \textbf{输出赋值}：
    \begin{itemize}
        \item 将生成的立即数和偏移量分别赋值给输出信号 \texttt{Imm} 和 \texttt{offset}。
    \end{itemize}
\end{enumerate}


\begin{lstlisting}[language=Verilog,caption=立即数]
  //立即数
  //设置Shift信号
  wire Shift;
  assign Shift=(funct3==3'b001)||(funct3==3'b101);

  reg [31:0] Imm_temp,offset_temp;
  //Imm
  always @(*) begin
    if (I_type==1 && Shift==1)begin
      Imm_temp = { 27'd0, Instruction[24:20] }; //shift
    end
    else if (I_type==1 && Shift==0)begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:20] };//immediate
    end
    else if (LW==1) begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:20] };//load
    end
    else if (SW==1)begin
      Imm_temp = { {20{Instruction[31]}}, Instruction[31:25], Instruction[11:7] }; //store
    end
    else if (LUI==1)begin
      Imm_temp = { Instruction[31:12], 12'd0 }; //LUI
    end
    else if (AUIPC==1)begin
      Imm_temp = { Instruction[31:12], 12'd0 }; //AUIPC
    end
    else begin
      Imm_temp = 32'b0;//default
    end
  end
  //offset
  always @(*) begin
    if (JALR==1) begin
      offset_temp = { {20{Instruction[31]}}, Instruction[31:20] };//JALR
    end
    else if (JAL==1) begin
      offset_temp = { {11{Instruction[31]}}, Instruction[31], Instruction[19:12], Instruction[20], Instruction[30:21], 1'b0 };//JAL
    end
    else if (SB_type==1) begin
      offset_temp = { {19{Instruction[31]}}, Instruction[31], Instruction[7], Instruction[30:25], Instruction[11:8], 1'b0 };//SB
    end
    else begin
      offset_temp = 32'b0;//default
    end
  end
  assign Imm=Imm_temp;
  assign offset=offset_temp;
\end{lstlisting}

\subsubsection*
{\Large 仿真结果}
\normalsize

\textcolor{red}{\textbf{由于目前只使用到功能仿真进行测试，因此本人在设计模块时使用了更加轻量级的仿真工具，有利于快速和方便的进行功能测试。}}

\textcolor{red}{\textbf{后续在构建vivado工程后，将使用vivado自带的仿真工具进行功能和时序仿真，以进一步验证设计的正确性。}}

使用如下的仿真文件进程测试仿真。
\begin{lstlisting}[language=Verilog,caption=仿真tb文件]
	initial begin
		// Initialize Inputs
		$dumpfile("Decode.vcd");
        $dumpvars;
		Instruction = 32'h00003f37;//lui  X30, 0x3000	
        
		// Add stimulus here		
		#200 Instruction = 32'h02000fe7;//jalr X31, later(X0)
		#200 Instruction = 32'h00001c63;//bne  X0, X0, end
		#200 Instruction = 32'h042f0293;//addi X5, X30, 42
		#200 Instruction = 32'h01f00333;//add  X6, X0, X31
		#200 Instruction  = 32'h406283b3;//sub  X7, X5, X6		
		#200 Instruction = 32'h0053ee33;//or	 X28, X7, X5		
		#200 Instruction = 32'hfc000ae3;//beq X0, X0, earlier
		#200 Instruction = 32'h001c2623;//sw  X28, 0C(X0)	
		#200 Instruction = 32'h00432e83;//lw X29, 04(X6)
		#200 Instruction = 32'h002e9293;//sll X5, X29,2
		#200 Instruction = 32'h00733e33;//sltu X28, X6,X7
		#200 Instruction = 32'h0000f6f;//jal  X31, done
	
        #200 $finish;
	end
\end{lstlisting}
  \newpage

    具体仿真结果如下图所示。
    上方信号为输入信号Instruction，下方信号为对应的各种译码后的输出信号。
    通过对不同指令的译码结果进行观察，可以验证译码模块的正确性。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim1.png}
    \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim2.png}
        \caption{仿真结果}
    \end{figure}

















  \newpage

\subsection{寄存器堆Resigter子模块}
\subsubsection*{\Large 设计原理}
\normalsize
寄存器堆由 32 个 32 位寄存器组成，这些寄存器通过寄存器号进行读写存取。
寄存器堆的原理框图如下图所示。因为读取寄存器不会更改其内容，故只需提供寄存器号即可读出该寄存器内容。
读取端口采用数据选择器即可实现读取功能。应注意的是，“0”号寄存器为常数 0。

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image5.png}
        \caption{寄存器堆原理框图}
    \end{figure}



对于往寄存器里写数据，需要目标寄存器号（WriteRegister）、待写入数据（WriteData）、
写允许信号（RegWrite）三个变量。上图中 5 位二进制译码器完成地址译码，
其输出控制目标寄存器的写使能信号 EN，决定将数据 WriteData 写入哪个寄存器。

注意：用 Verilog HDL 设计描述寄存器堆时，用存储器变量定义 32 个 32 位寄存器更为方便。
下面为描述寄存器堆核心语句。

\begin{verbatim}
reg [31:0] regs [31:0]; // 定义 32*32 存储器变量
assign ReadData1 = (ReadRegister1 == 5'b0) ? 32'b0 : regs[ReadRegister1]; // 端口1读
assign ReadData2 = (ReadRegister2 == 5'b0) ? 32'b0 : regs[ReadRegister2]; // 端口2读
always @ (posedge clk) if (RegWrite) regs[WriteRegister] <= WriteData; // 数据写入
\end{verbatim}

在流水线型 CPU 设计中，寄存器堆设计还应解决三阶数据相关的数据转发问题。
当满足三阶数据相关条件时，寄存器具有 Read After Write 特性。
设计时，只需要在上图设计寄存器堆的基础上添加少量电路就可实现 Read After Write 特性，
如下图所示。图中的 RBW\_Registers 模块就是实现的 Read Before Write 寄存器堆。图中转发检测电路的输出表达式为

\begin{align*}
rs1Sel &= RegWrite \&\& (WriteAddr != 0) \&\& (WriteAddr == rs1Addr)  \\
rs2Sel &= RegWrite \&\& (WriteAddr != 0) \&\& (WriteAddr == rs2Addr) 
\end{align*}

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image5.png}
        \caption{Read After Write 寄存器堆}
    \end{figure}

\newpage
\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize
这部分代码实现了一个简单的寄存器堆
\begin{enumerate}
    \item \textbf{寄存器堆定义}：
    \begin{itemize}
        \item 使用 \texttt{reg[31:0] regs[31:0]} 定义一个32个32位寄存器的寄存器堆。
    \end{itemize}

    \item \textbf{读取数据}：
    \begin{itemize}
        \item 通过 \texttt{assign} 语句实现读取数据的逻辑。
        \item 如果读取地址为0（即x0寄存器），则读取数据为0。
        \item 否则，从寄存器堆中读取相应地址的数据。
    \end{itemize}

    \item \textbf{写入数据}：
    \begin{itemize}
        \item 使用 \texttt{always @(posedge clk)} 块在时钟上升沿进行写入操作。
        \item 如果 \texttt{RegWrite} 信号有效，则将 \texttt{WriteData} 写入到指定的寄存器地址。
    \end{itemize}
\end{enumerate}




\begin{lstlisting}[language=Verilog,caption={寄存器堆}]
//寄存器堆
module Register (
    input wire clk,
    input [4:0] ReadRegister1,ReadRegister2,//读取寄存器的地址
    input [4:0] WriteRegister, //写入寄存器的地址
    input RegWrite, //写使能信号
    input [31:0] WriteData, //写入数据
    output [31:0] ReadData1,ReadData2 //读取数据
);
    reg[31:0] regs[31:0];//寄存器堆
    assign ReadData1 = (ReadRegister1==5'b0)?32'b0:regs[ReadRegister1];//x0寄存器始终为0,端口1读取
    assign ReadData2 = (ReadRegister2==5'b0)?32'b0:regs[ReadRegister2];//x0寄存器始终为0,端口2读取
    always @(posedge clk) begin
        //写入数据
        if(RegWrite) begin
            regs[WriteRegister] <= WriteData;
        end
    end
endmodule
\end{lstlisting}

\newpage

这部分代码实现了一个Read After Write寄存器堆，用于解决数据冒险问题。
具体分析如下：
\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{clk}：时钟信号。
        \item \texttt{rs1Addr} 和 \texttt{rs2Addr}：读取寄存器的地址。
        \item \texttt{WriteAddr}：写入寄存器的地址。
        \item \texttt{RegWrite}：写使能信号。
        \item \texttt{WriteData}：写入的数据。
        \item \texttt{rs1Data} 和 \texttt{rs2Data}：读取的数据。
    \end{itemize}

    \item \textbf{选择信号}：
    \begin{itemize}
        \item 定义了 \texttt{rs1Sel} 和 \texttt{rs2Sel} 信号，用于判断是否存在数据冒险。
        \item 当 \texttt{RegWrite} 有效且写入地址与读取地址相同时，选择信号为高。
    \end{itemize}

    \item \textbf{寄存器堆实例化}：
    \begin{itemize}
        \item 实例化一个 \texttt{Register} 模块，用于实际的寄存器堆操作。
        \item 通过 \texttt{Register} 模块读取寄存器数据，并将结果存储在 \texttt{RBW\_rdData1} 和 \texttt{RBW\_rdData2} 中。
    \end{itemize}

    \item \textbf{数据选择}：
    \begin{itemize}
        \item 根据选择信号 \texttt{rs1Sel} 和 \texttt{rs2Sel}，决定输出数据是来自写入数据还是寄存器堆读取的数据。
        \item 如果存在数据冒险，则输出写入数据；否则，输出寄存器堆读取的数据。
    \end{itemize}
\end{enumerate}


\begin{lstlisting}[language=Verilog,caption={RAW寄存器堆}]
//RAW寄存器堆
module RAWRegister(
    input wire clk,
    input [4:0] rs1Addr,rs2Addr,//读取寄存器的地址`
    input [4:0] WriteAddr, //写入寄存器的地址
    input RegWrite, //写使能信号
    input [31:0] WriteData, //写入数据
    output [31:0] rs1Data,rs2Data //读取数据
);
    wire rs1Sel,rs2Sel;
    assign rs1Sel = RegWrite && (WriteAddr != 5'b0) && (WriteAddr == rs1Addr);
    assign rs2Sel = RegWrite && (WriteAddr != 5'b0) && (WriteAddr == rs2Addr);
    wire [31:0] RBW_rdData1,RBW_rdData2;
    Register RBW_Register(
        .clk(clk),
        .ReadRegister1(rs1Addr),
        .ReadRegister2(rs2Addr),
        .WriteRegister(WriteAddr),
        .RegWrite(RegWrite),
        .WriteData(WriteData),
        .ReadData1(RBW_rdData1),
        .ReadData2(RBW_rdData2)
    );    
    assign rs1Data = rs1Sel?WriteData:RBW_rdData1;
    assign rs2Data = rs2Sel?WriteData:RBW_rdData2;
endmodule
\end{lstlisting}

















\subsubsection*{\Large  仿真结果}
\normalsize



自己写了一段仿真文件进程测试仿真。
\begin{lstlisting}[language=Verilog,caption=寄存器堆仿真tb文件]
  initial begin
    $dumpfile("RAWRegister.vcd");
    $dumpvars(0, RAWRegister_tb);

    // 监视寄存器数组的每个元素
    for (i = 0; i < 32; i = i + 1) begin
      $dumpvars(0, RAWRegister_tb.RAWRegister_inst.RBW_Register.regs[i]);
    end

    // 初始化信号
    rs1Addr = 5'b0;
    rs2Addr = 5'b0;
    WriteAddr = 5'b0;
    RegWrite = 1'b0;
    WriteData = 32'b0;

    // 写入数据到寄存器1
    #DELY;
    WriteAddr = 5'd1;
    WriteData = 32'hA5A5A5A5;
    RegWrite = 1'b1;
    #DELY;
    RegWrite = 1'b0;

    // 读取寄存器1的数据
    #DELY;
    rs1Addr = 5'd1;
    rs2Addr = 5'd0;
    #DELY;

    // 写入数据到寄存器2
    #DELY;
    WriteAddr = 5'd2;
    WriteData = 32'h5A5A5A5A;
    RegWrite = 1'b1;
    #DELY;
    RegWrite = 1'b0;

    // 读取寄存器2的数据
    #DELY;
    rs1Addr = 5'd0;
    rs2Addr = 5'd2;
    #DELY;

    // 写入数据到寄存器1和寄存器2
    #DELY;
    WriteAddr = 5'd1;
    WriteData = 32'hFFFFFFFF;
    RegWrite = 1'b1;
    #DELY;
    WriteAddr = 5'd2;
    WriteData = 32'h00000000;
    #DELY;
    RegWrite = 1'b0;

    // 读取寄存器1和寄存器2的数据
    #DELY;
    rs1Addr = 5'd1;
    rs2Addr = 5'd2;
    #DELY;

    // 结束仿真
    $finish;
\end{lstlisting}

\newpage

    具体仿真结果如下图所示。可以看到信号的变化过程，以及对应的寄存器堆的读写操作。
    仿真的结果显示的信号行为与测试文件中的操作是一致的，说明寄存器堆的设计是正确的。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim3.png}
        \caption{仿真结果}
    \end{figure}
  \newpage




%——————————————————————————————————————————————————————


\subsection{ID模块}
\subsubsection*{\Large 设计原理}
\normalsize
  设计原理如下所示,ID 模块分为4个部分，分别是前面介绍的Decoder模块，RAW寄存器堆模块，以及剩下的两个部分：分支检测电路和冒险检测电路模块。

  分支检测电路主要用于判断分支条件是否成立，在 Verilog HDL 可以用比较运算符号 “>”、“<” 和 “==” 描述，但要注意符号数和无符号数的处理方法不同。在这里，我们用加法器来实现。

\begin{enumerate}
    \item 用一个 32 位加法器完成 rs1Data + (-rs2Data) + 1（即 rs1Data - rs2Data），设结果为 sum[31:0]。
    \item 确定比较运算的结果。对于比较运算来说，如果最高位不同，即 rs1Data[31] ≠ rs2Data[31]，可根据 rs1Data[31]、rs2Data[31] 决定比较结果，但是应注意符号数、无符号数的最高位 rs1Data[31]、rs2Data[31] 代表意义不同。若两数最高位相同，则两数之差不会溢出，所以比较运算结果可由两个操作数之差的符号位 sum[31] 决定。
\end{enumerate}

在符号数比较运算中，$rs1Data < rs2Data$ 有以下两种情况：

\begin{enumerate}
    \item $rs1Data$ 为负数，$rs2Data$ 为 0 或正数：$(rs1Data[31] \& \& (\sim rs2Data[31]))$
    \item $rs1Data$、$rs2Data$ 符号相同，$sum$ 为负：$(rs1Data[31] \sim rs2Data[31]) \&\& sum[31]$
\end{enumerate}

因此，符号数 $rs1Data < rs2Data$ 比较运算结果为
\begin{equation}
isLT = (rs1Data[31] \& \& (\sim rs2Data[31])) || ((rs1Data[31] \sim rs2Data[31]) \&\& sum[31]) 
\end{equation}

同样地，无符号数比较运算中，$rs1Data < rs2Data$ 有以下两种情况：

\begin{enumerate}
    \item $rs1Data$ 最高位为 0、$rs2Data$ 最高位为 1：$(\sim rs1Data[31]) \&\& rs2Data[31]$
    \item $rs1Data$、$rs2Data$ 最高位相同，$sum$ 为负：$(rs1Data[31] \sim rs2Data[31]) \&\& sum[31]$
\end{enumerate}

因此，无符号数比较运算结果为
\begin{equation}
isLTU = ((\sim rs1Data[31]) \&\& rs2Data[31]) || ((rs1Data[31] \sim rs2Data[31]) \&\& sum[31]) 
\end{equation}

最后用数据选择器,即可完成分支检测。

\[
\text{Branch} = 
\begin{cases} 
\neg (\text{sum}[31:0]), & \text{SB\_type} \land (\text{funct3} == \text{beq\_funct3}) \\
\text{sum}[31:0], & \text{SB\_type} \land (\text{funct3} == \text{bne\_funct3}) \\
\text{isLT}, & \text{SB\_type} \land (\text{funct3} == \text{blt\_funct3}) \\
\neg \text{isLT}, & \text{SB\_type} \land (\text{funct3} == \text{bge\_funct3}) \\
\text{isLTU}, & \text{SB\_type} \land (\text{funct3} == \text{bltu\_funct3}) \\
\neg \text{isLTU}, & \text{SB\_type} \land (\text{funct3} == \text{bgeu\_funct3}) \\
0, & \text{others}
\end{cases}
\]


由前面分析可知，冒险成立的条件为：
\begin{enumerate}
    \item 上一条指令必须是 lw 指令（MemRead\_ex=1）；
    \item 两条指令读写同一个寄存器（rdAddr\_ex=rs1Addr\_id 或 rdAddr\_ex=rs2Addr\_id）。
\end{enumerate}
当冒险成立应清空 ID/EX 寄存器并且阻塞流水线 ID 级、IF 级流水线，所以有
\begin{align*}
Stall &= ((rdAddr\_ex == rs1Addr\_id) || (rdAddr\_ex == rs2Addr\_id)) \&\& MemRead\_ex  \\
IFWrite &= \sim Stall 
\end{align*}

在用 VerilogHDL 描述 ID 模块时，冒险检测功能电路（Hazard Detector）等功能单元比较简单，直接在 ID 顶层描述。
  
\textbf{最后，ID顶层模块的接口信息如下}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fig/image7.png}
    \caption{ID顶层模块接口}
\end{figure}

\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize

首先实现分支测试模块，用于判断分支条件是否成立

\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{rs1Data} 和 \texttt{rs2Data}：两个操作数的数据。
        \item \texttt{SB\_type}：指示是否为分支指令。
        \item \texttt{funct3}：功能码，用于区分不同的分支条件。
        \item \texttt{Branch}：输出信号，指示分支条件是否成立。
    \end{itemize}

    \item \textbf{比较信号}：
    \begin{itemize}
        \item \texttt{isLT} 和 \texttt{isLTU}：用于比较两个操作数的大小。
        \item \texttt{sum}：两个操作数的差值，用于判断相等和不等条件。
    \end{itemize}

    \item \textbf{分支条件判断}：
    \begin{itemize}
        \item 使用 \texttt{always @(*)} 块，根据 \texttt{SB\_type} 和 \texttt{funct3} 的值判断分支条件是否成立。
        \item 对于不同的 \texttt{funct3} 值，判断相应的分支条件。例如：
        \begin{itemize}
            \item \texttt{beq\_funct3}：判断两个操作数是否相等。
            \item \texttt{bne\_funct3}：判断两个操作数是否不等。
            \item \texttt{blt\_funct3}：判断第一个操作数是否小于第二个操作数（有符号）。
            \item \texttt{bge\_funct3}：判断第一个操作数是否大于等于第二个操作数（有符号）。
            \item \texttt{bltu\_funct3}：判断第一个操作数是否小于第二个操作数（无符号）。
            \item \texttt{bgeu\_funct3}：判断第一个操作数是否大于等于第二个操作数（无符号）。
        \end{itemize}
    \end{itemize}

    \item \textbf{输出赋值}：
    \begin{itemize}
        \item 将判断结果赋值给输出信号 \texttt{Branch}。
    \end{itemize}
\end{enumerate}



\begin{lstlisting}[language=Verilog,caption={Branch Test模块}]
module BranchTest (
    input wire [31:0] rs1Data,
    input wire [31:0] rs2Data,
    input wire SB_type,
    input wire [2:0] funct3,
    output wire Branch
);
    // 比较两个操作数的大小
    wire isLT, isLTU;
    wire [31:0] sum;
    assign sum = rs1Data + ~rs2Data + 1;
    assign isLT = rs1Data[31] && (~rs2Data[31]) || (rs1Data[31] ~^ rs2Data[31]) && sum[31];
    assign isLTU = (~rs1Data[31]) && rs2Data[31] || (rs1Data[31] ~^ rs2Data[31]) && sum[31];
    reg Branch_temp;

    // 定义 funct3 的值
    localparam beq_funct3 = 3'b000;
    localparam bne_funct3 = 3'b001;
    localparam blt_funct3 = 3'b100;
    localparam bge_funct3 = 3'b101;
    localparam bltu_funct3 = 3'b110;
    localparam bgeu_funct3 = 3'b111;
    // 判断分支条件是否成立
    always @(*) begin
        if (SB_type == 1 && funct3 == beq_funct3) begin
            Branch_temp = ~(|sum[31:0]);
        end
        else if (SB_type == 1 && funct3 == bne_funct3) begin
            Branch_temp = |sum[31:0];
        end
        else if (SB_type == 1 && funct3 == blt_funct3) begin
            Branch_temp = isLT;
        end
        else if (SB_type == 1 && funct3 == bge_funct3) begin
            Branch_temp = ~isLT;
        end
        else if (SB_type == 1 && funct3 == bltu_funct3) begin
            Branch_temp = isLTU;
        end
        else if (SB_type == 1 && funct3 == bgeu_funct3) begin
            Branch_temp = ~isLTU;
        end
        else begin
            Branch_temp = 0;
        end
    end
    // 赋值输出信号
    assign Branch = Branch_temp;
endmodule
\end{lstlisting}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{figures/fig/image8.png}
    \caption{ID顶层输入输出信号参考图}
\end{figure}

之后实现顶层ID模块，包括Decoder模块，RAW寄存器堆模块，分支检测电路模块和冒险检测电路模块。
具体介绍如下：
\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{clk}：时钟信号。
        \item \texttt{Instruction\_id}：当前指令。
        \item \texttt{PC\_id}：当前程序计数器值。
        \item \texttt{RegWrite\_wb}：写回阶段的写使能信号。
        \item \texttt{rdAddr\_wb}：写回阶段的目标寄存器地址。
        \item \texttt{RegWriteData\_wb}：写回阶段的数据。
        \item \texttt{MemRead\_ex}：执行阶段的内存读信号。
        \item \texttt{rdAddr\_ex}：执行阶段的目标寄存器地址。
        \item \texttt{MemtoReg\_id}、\texttt{RegWrite\_id}、\texttt{MemWrite\_id}、\texttt{MemRead\_id}：ID阶段的控制信号。
        \item \texttt{ALUCode\_id}、\texttt{ALUSrcA\_id}、\texttt{ALUSrcB\_id}：ALU控制信号。
        \item \texttt{Stall}：流水线暂停信号。
        \item \texttt{Branch}：分支信号。
        \item \texttt{Jump}：跳转信号。
        \item \texttt{IFWrite}：IF阶段写使能信号。
        \item \texttt{JumpAddr}：跳转地址。
        \item \texttt{Imm\_id}：立即数。
        \item \texttt{rs1Data\_id}、\texttt{rs2Data\_id}：读取的寄存器数据。
        \item \texttt{rs1Addr\_id}、\texttt{rs2Addr\_id}、\texttt{rdAddr\_id}：寄存器地址。
    \end{itemize}

    \item \textbf{信号分配}：
    \begin{itemize}
        \item 根据指令字段分配寄存器地址和功能码。
        \item 实例化 \texttt{RAWRegister} 模块，用于寄存器堆操作,根据参考图连接对应的信号
        \item 实例化 \texttt{Decode} 模块，用于指令译码，根据参考图连接对应的信号
        \item 实例化 \texttt{BranchTest} 模块，用于分支条件判断，根据参考图连接对应的信号
    \end{itemize}

    \item \textbf{跳转地址和暂停信号}：
    \begin{itemize}
        \item 根据 \texttt{JALR} 信号和偏移量计算跳转地址。
        \item 根据执行阶段的内存读信号和寄存器地址判断是否需要暂停流水线。
    \end{itemize}
\end{enumerate}


\begin{lstlisting}[language=Verilog,caption={ID顶层模块}]
module ID(clk,Instruction_id, PC_id, RegWrite_wb, rdAddr_wb, RegWriteData_wb, MemRead_ex, 
          rdAddr_ex, MemtoReg_id, RegWrite_id, MemWrite_id, MemRead_id, ALUCode_id, 
			 ALUSrcA_id, ALUSrcB_id,  Stall, Branch, Jump, IFWrite,  JumpAddr, Imm_id,
			 rs1Data_id, rs2Data_id,rs1Addr_id,rs2Addr_id,rdAddr_id);
    //输入输出信号定义
    input clk;
    input [31:0] Instruction_id;
    input [31:0] PC_id;
    input RegWrite_wb;
    input [4:0] rdAddr_wb;
    input [31:0] RegWriteData_wb;
    input MemRead_ex;
    input [4:0] rdAddr_ex;
    output MemtoReg_id;
    output RegWrite_id;
    output MemWrite_id;
    output MemRead_id;
    output [3:0] ALUCode_id;
    output ALUSrcA_id;
    output [1:0]ALUSrcB_id;
    output Stall;
    output Branch;
    output Jump;
    output IFWrite;
    output [31:0] JumpAddr;
    output [31:0] Imm_id;
    output [31:0] rs1Data_id;
    output [31:0] rs2Data_id;
	output[4:0] rs1Addr_id,rs2Addr_id,rdAddr_id;
    //内部信号定义
    wire JALR;
    wire [31:0]offset_id;
    wire SB_type_id;
    wire [2:0] funct3_id;
    assign SB_type_id = (Instruction_id[6:0] == 7'b1100011);
    assign funct3_id = Instruction_id[14:12];

    assign rs1Addr_id = Instruction_id[19:15];
    assign rs2Addr_id = Instruction_id[24:20];
    assign rdAddr_id = Instruction_id[11:7];
    //实例化RAW寄存器堆模块
    RAWRegister Registers(
        .clk(clk),
        .rs1Addr(rs1Addr_id),
        .rs2Addr(rs2Addr_id),
        .WriteAddr(rdAddr_wb),
        .RegWrite(RegWrite_wb),
        .WriteData(RegWriteData_wb),
        .rs1Data(rs1Data_id),
        .rs2Data(rs2Data_id)
    );
    //实例化译码模块
    Decode Decode_inst(
        .Instruction(Instruction_id),
        .JALR(JALR),
        .MemtoReg(MemtoReg_id),
        .RegWrite(RegWrite_id),
        .MemWrite(MemWrite_id),
        .MemRead(MemRead_id),
        .ALUCode(ALUCode_id),
        .ALUSrcA(ALUSrcA_id),
        .ALUSrcB(ALUSrcB_id),
        .Imm(Imm_id),
        .Jump(Jump),
        .offset(offset_id)
    );
    //实例化分支测试模块
    BranchTest BranchTest_inst(
        .rs1Data(rs1Data_id),
        .rs2Data(rs2Data_id),
        .SB_type(SB_type_id),
        .funct3(funct3_id),
        .Branch(Branch)
    );
    //计算跳转地址
    assign JumpAddr=(JALR==1)?(rs1Data_id+offset_id):(PC_id+offset_id);
    //冒险检测电路
    assign Stall=((rdAddr_ex==rs1Addr_id)||(rdAddr_ex==rs2Addr_id))&&MemRead_ex;
    assign IFWrite=~Stall;
endmodule
\end{lstlisting}


\newpage

\subsubsection*{\Large 仿真结果}
\normalsize

自己写了一段仿真文件进行测试仿真，只测试了BranchTest模块，
ID 顶层模块较为复杂，最后在CPU顶层模块中进行整体测试
\begin{lstlisting}[language=Verilog,caption=BranchTest仿真文件]
  initial begin
    $dumpfile("BranchTest.vcd");
    $dumpvars(0, BranchTest_tb);
    // 初始化信号
    rs1Data = 32'b0;
    rs2Data = 32'b0;
    SB_type = 1'b0;
    funct3 = 3'b000;
    // 测试 beq_funct3
    #10;
    SB_type = 1'b1;
    funct3 = 3'b000; // beq_funct3
    rs1Data = 32'h00000000;
    rs2Data = 32'h00000000;
    #10;
    rs1Data = 32'hff000001;
    rs2Data = 32'hff000001;
    #10;
    rs1Data = 32'h10000001;
    rs2Data = 32'h10000002;
    // 测试 bne_funct3
    #10;
    funct3 = 3'b001; // bne_funct3
    rs1Data = 32'hf0000000;
    rs2Data = 32'hf0000001;
    #10;
    rs1Data = 32'hf0000001;
    rs2Data = 32'hf0000001;
    // 测试 blt_funct3
    #10;
    funct3 = 3'b100; // blt_funct3
    rs1Data = 32'hf0000001;
    rs2Data = 32'h00000002;
    #10;
    rs1Data = 32'hFFFFFFFF;
    rs2Data = 32'hf0000001;
    // 测试 bge_funct3
    #10;
    funct3 = 3'b101; // bge_funct3
    rs1Data = 32'h00000002;
    rs2Data = 32'h00000001;
    #10;
    rs1Data = 32'hf0000001;
    rs2Data = 32'hff000002;
    // 测试 bltu_funct3
    #10;
    funct3 = 3'b110; // bltu_funct3
    rs1Data = 32'h00000001;
    rs2Data = 32'hf0000002;
    #10;
    rs1Data = 32'hf0000002;
    rs2Data = 32'h00000001;
    // 测试 bgeu_funct3
    #10;
    funct3 = 3'b111; // bgeu_funct3
    rs1Data = 32'h00000002;
    rs2Data = 32'h0f000001;
    #10;
    rs1Data = 32'h00000001;
    rs2Data = 32'hff000002;
    // 结束仿真
    #10;
    $finish;
\end{lstlisting}


    具体仿真结果如下图所示。对照测试文件，仿真结果正确。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim4.png}
        \caption{仿真结果}
    \end{figure}

  \newpage




%——————————————————————————————————————4


\subsection{ALU子模块}
\subsubsection*{\Large 设计原理}
\normalsize
算术逻辑运算单元（ALU）提供CPU的基本运算能力，
如加、减、与、或、比较、移位等。具体而言，
ALU输入为两个操作数A、B和控制信号ALUCode，
由控制信号ALUCode决定采用何种运算，运算结果为ALUResult。
ALU的功能表，如下图所示。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image9.png}
        \caption{ALU功能表}
    \end{figure}

如图所示所示，ALU需执行多种运算，为了提高运算速度，
本设计可同时进行各种运算，再根据ALUCode信号选出所需结果。
ALU的基本结构如下图所示。

\subsubsection*{加、减电路的设计考虑}
减法、比较（slt、sltu）均可用加法器和必要辅助电路来实现。
图30.10中的Binvert信号控制加减运算：若Binvert信号为低电平，
则实现加法运算：sum=A+B；若Binvert信号为高电平，
则电路为减法运算sum=A-B。除加法外，减法、比较和分支指令都应使电路
工作在减法状态，所以：
\begin{equation}
Binvert = \sim(ALUCode == 0) 
\end{equation}

最后要强调的是，32位加法器的运算速度决定了RISC-V微处理器的时钟信号
频率的高低，因此设计一个高速的32位加法器尤为重要。32位加法器可采用
实验8介绍的进位选择加法器。


    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image10.png}
        \caption{ALU结构图}
    \end{figure}

\subsubsection*{②比较电路的设计考虑}
比较电路的设计方法su'bsub检测电路介绍，参考式(30.12)和式(30.13)可确定slt和sltu两条件的比较结果。

\subsubsection*{③算术右移运算电路的设计考虑}
算术右移对有符号数而言，移出的高位补符号位而不是0。每右移一位相当于除以2。例如，有符号数负数101001100(-76)算术右移两位结果为111010001(-19)，正数01100111(103)算术右移一位结果为000110011(51)。

Verilog HDL的算术右移的运算符是“\textgreater\textgreater”。要实现算术右移应注意，被移位的对象必须定义是reg类型，但是在sra指令，被移位的对象操作数A为输入信号，不能定义为reg类型。因此，必须引入reg类型中间变量A\_reg，相应的Verilog HDL语句为
\begin{verbatim}
reg signed[31:0] A_reg;
always @(*) begin A_reg = A; end
\end{verbatim}

引入reg类型的中间变量A\_reg后，就可对A\_reg进行算术右移操作。



\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize

\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{ALUCode}：操作选择信号。
        \item \texttt{A} 和 \texttt{B}：操作数。
        \item \texttt{ALUResult}：运算结果。
    \end{itemize}

    \item \textbf{参数定义}：
    \begin{itemize}
        \item 定义了多个参数用于选择ALU的操作，如 \texttt{alu\_add}、\texttt{alu\_sub}、\texttt{alu\_and} 等。
    \end{itemize}

    \item \textbf{内部信号}：
    \begin{itemize}
        \item 定义了内部信号 \texttt{Binvert}、\texttt{b}、\texttt{sum} 等，用于实现不同的ALU操作。
    \end{itemize}

    \item \textbf{加法器}：
    \begin{itemize}
        \item 实例化了一个32位加法器 \texttt{adder\_32bits}，用于实现加法和减法操作。
    \end{itemize}

    \item \textbf{逻辑运算和移位操作}：
    \begin{itemize}
        \item 使用位运算和移位操作实现了 \texttt{and}、\texttt{xor}、\texttt{or}、\texttt{sll}、\texttt{srl} 和 \texttt{sra} 操作。
    \end{itemize}

    \item \textbf{比较操作}：
    \begin{itemize}
        \item 使用比较操作实现了 \texttt{slt} 和 \texttt{sltu} 操作。
    \end{itemize}

    \item \textbf{多路选择器}：
    \begin{itemize}
        \item 使用多路选择器根据 \texttt{ALUCode} 的值选择相应的运算结果。
    \end{itemize}

    \item \textbf{输出赋值}：
    \begin{itemize}
        \item 将选择的运算结果赋值给输出信号 \texttt{ALUResult}。
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Verilog,caption=ALU模块]
module ALU (
	// Outputs
	   ALUResult,
	// Inputs
	   ALUCode, A, B);
	input [3:0]	ALUCode;				// Operation select
	input [31:0]	A, B;
	output [31:0]	ALUResult;
	
// Decoded ALU operation select (ALUsel) signals
// 参数用于选择ALU的操作
   parameter	 alu_add=  4'b0000;
   parameter	 alu_sub=  4'b0001;
   parameter	 alu_lui=  4'b0010;
   parameter	 alu_and=  4'b0011;
   parameter	 alu_xor=  4'b0100;
   parameter	 alu_or =  4'b0101;
   parameter 	 alu_sll=  4'b0110;
   parameter	 alu_srl=  4'b0111;
   parameter	 alu_sra=  4'b1000;
   parameter	 alu_slt=  4'b1001;
   parameter	 alu_sltu= 4'b1010; 	
   //定义内部信号
   wire Binvert;
   wire [31:0] b,sum,d3,d4,d5,d6,d7,d8,d9,d10;
   reg signed [31:0] A_reg;
   reg [31:0]out;
   //加减控制  
   assign Binvert = ~(ALUCode==0);
   //位拓展
   assign b = {32{Binvert}} ^ B;
   //加法器，用到了lab8中的快速加法器
   adder_32bits adder_32bits_ALUinst (
      .a(A),
      .b(b),
      .ci(Binvert),
      .s(sum),
      .co()
   );
   //d3 and
   assign d3=A&B;
   //d4 xor
   assign d4=A^B;
   //d5 or
   assign d5=A|B;
   //d6 sll
   assign d6=A<<B[4:0];
   //d7 srl
   assign d7=A>>B[4:0];
   //d8 sra
   always @(*) begin A_reg=A; end
   assign d8=A_reg>>>B[4:0];
   //d9 slt
   assign d9=A[31] && (~B[31]) || (A[31]~^B[31]) && sum[31];
   //d10 sltu
   assign d10=(~A[31]) && B[31] || (A[31]~^B[31]) && sum[31];

   //多路选择器用于选择输出
   always @(*) begin
      if (ALUCode==alu_add) begin
         out=sum;
      end else if (ALUCode==alu_sub) begin
         out=sum;
      end else if (ALUCode==alu_lui) begin
         out=B;
      end else if (ALUCode==alu_and) begin
         out=d3;
      end else if (ALUCode==alu_xor) begin
         out=d4;
      end else if (ALUCode==alu_or) begin
         out=d5;
      end else if (ALUCode==alu_sll) begin
         out=d6;
      end else if (ALUCode==alu_srl) begin
         out=d7;
      end else if (ALUCode==alu_sra) begin
         out=d8;
      end else if (ALUCode==alu_slt) begin
         out=d9;
      end else if (ALUCode==alu_sltu) begin
         out=d10;
      end
      else begin
         out=sum;
      end
   end
   //赋值输出
   assign ALUResult=out;

endmodule
\end{lstlisting}



\newpage

\subsubsection*{\Large 仿真结果}
\normalsize

自己写了一段仿真文件进行模块测试,如下

\begin{lstlisting}[language=Verilog,caption=ALU仿真文件]
	initial begin
		// Initialize Inputs
		$dumpfile("ALU.vcd");
 		$dumpvars;
		ALUCode = 4'd0; A = 32'h00004012; B = 32'h1000200F;//add
		      
		// Add stimulus here
		#100 ALUCode = 4'd0; A = 32'h80000000;	B = 32'h80000000;//add
		#100 ALUCode = 4'd1; A = 32'h70F0C0E0;	B = 32'h10003054;//sub
		#100 ALUCode = 4'd2; A = 32'h70F0C0E0;	B = 32'h00003000;//lui
		#100 ALUCode = 4'd3; A = 32'hFF0C0E10;	B = 32'h10DF30FF;//and
		#100 ALUCode = 4'd4; A = 32'hFF0C0E10;	B = 32'h10DF30FF;//xor
		#100 ALUCode = 4'd5; A = 32'hFF0C0E10;	B = 32'h10DF30FF;//or
		#100 ALUCode = 4'd6; A = 32'hFFFFE0FF;	B = 32'h00000004;//sll
		#100 ALUCode = 4'd7; A = 32'hFFFFE0FF;	B = 32'h00000004;//srl
		#100 ALUCode = 4'd8; A = 32'hFFFFE0FF; B = 32'h00000004;//sra
		#100 ALUCode = 4'd9; A = 32'hFF000004;	B = 32'h700000FF;//slt
		#100 ALUCode = 4'd10;A = 32'hFF000004;	B = 32'h700000FF;//sltu
		#100 $finish;
	end
\end{lstlisting}


    具体仿真结果如下图所示。对照测试文件，仿真结果正确。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim5.png}
        \caption{仿真结果}
    \end{figure}

  \newpage






%——————————————————————————————————————5





\subsection{EX模块}

\subsubsection*{\Large 设计原理}
\normalsize

\textbf{EX模块包括ALU子模块和数据前推电路(用于转发数据)以及一些控制信号选择电路。}
\textbf{其中数据前推电路和控制信号选择电路较为简单直接在顶层模块中实现。}
数据前推电路设计如下：

操作数A和B分别由数据选择器决定，数据选择器地址信号ForwardA、ForwardB的含义如图所示。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image11.png}
        \caption{数据前推电路}
    \end{figure}
由前面介绍的一、二阶数据相关判断条件，不难得到

\begin{align*}
ForwardA[0] &= RegWrite\_wb \&\& (rdAddr\_wb \neq 0) \&\& (rdAddr\_mem \neq rs1Addr\_ex) \&\& \nonumber \\
&\quad (rdAddr\_wb == rs1Addr\_ex) \\
ForwardA[1] &= RegWrite\_mem \&\& (rdAddr\_mem \neq 0) \&\& (rdAddr\_mem == rs1Addr\_ex) \\
ForwardB[0] &= RegWrite\_wb \&\& (rdAddr\_wb \neq 0) \&\& (rdAddr\_mem \neq rs2Addr\_ex) \&\& \nonumber \\
&\quad (rdAddr\_wb == rs2Addr\_ex) \\
ForwardB[1] &= RegWrite\_mem \&\& (rdAddr\_mem \neq 0) \&\& (rdAddr\_mem == rs2Addr\_ex)
\end{align*}
  

\textbf{最后EX顶层的信号定义如下：}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image12.png}
        \caption{EX顶层信号定义}
    \end{figure}






\subsubsection*{\Large Verilog HDL代码与设计分析}

\normalsize
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/fig/image13.png}
        \caption{EX模块结构图}
    \end{figure}
参考上面的结构图，EX模块的设计如下：
\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{ALUCode\_ex}：ALU操作选择信号。
        \item \texttt{ALUSrcA\_ex} 和 \texttt{ALUSrcB\_ex}：ALU操作数选择信号。
        \item \texttt{Imm\_ex}：立即数。
        \item \texttt{rs1Addr\_ex} 和 \texttt{rs2Addr\_ex}：源寄存器地址。
        \item \texttt{rs1Data\_ex} 和 \texttt{rs2Data\_ex}：源寄存器数据。
        \item \texttt{PC\_ex}：程序计数器。
        \item \texttt{RegWriteData\_wb}：写回数据。
        \item \texttt{ALUResult\_mem}：ALU结果。
        \item \texttt{rdAddr\_mem} 和 \texttt{rdAddr\_wb}：目标寄存器地址。
        \item \texttt{RegWrite\_mem} 和 \texttt{RegWrite\_wb}：写使能信号。
        \item \texttt{ALUResult\_ex}：ALU运算结果。
        \item \texttt{MemWriteData\_ex}：写入内存的数据。
        \item \texttt{ALU\_A} 和 \texttt{ALU\_B}：ALU操作数。
    \end{itemize}

    \item \textbf{数据前推电路}：
    \begin{itemize}
        \item 定义了 \texttt{ForwardA} 和 \texttt{ForwardB} 信号，用于数据前推。
        \item 根据写使能信号和寄存器地址判断是否需要前推数据。
    \end{itemize}

    \item \textbf{数据转发MUX结果}：
    \begin{itemize}
        \item 使用多路选择器选择操作数A和B的来源。
        \item 根据 \texttt{ForwardA} 和 \texttt{ForwardB} 信号选择数据来源。
    \end{itemize}

    \item \textbf{ALU操作数MUX}：
    \begin{itemize}
        \item 根据 \texttt{ALUSrcA\_ex} 和 \texttt{ALUSrcB\_ex} 信号选择ALU操作数。
        \item 如果 \texttt{ALUSrcA\_ex} 为高，则选择 \texttt{PC\_ex} 作为操作数A，否则选择转发后的数据A。
        \item 如果 \texttt{ALUSrcB\_ex} 为 \texttt{2'b00}，则选择转发后的数据B；如果为 \texttt{2'b01}，则选择立即数；否则选择常数4。
    \end{itemize}

    \item \textbf{实例化ALU}：
    \begin{itemize}
        \item 实例化ALU模块，并将操作数和操作选择信号传递给ALU。
        \item 将ALU的运算结果输出到 \texttt{ALUResult\_ex}。
    \end{itemize}
\end{enumerate}


\begin{lstlisting}[language=Verilog,caption=EX顶层模块]
module EX(ALUCode_ex, ALUSrcA_ex, ALUSrcB_ex,Imm_ex, rs1Addr_ex, rs2Addr_ex, rs1Data_ex, 
          rs2Data_ex, PC_ex, RegWriteData_wb, ALUResult_mem,rdAddr_mem, rdAddr_wb, 
		  RegWrite_mem, RegWrite_wb, ALUResult_ex, MemWriteData_ex, ALU_A, ALU_B);
    input [3:0] ALUCode_ex;
    input ALUSrcA_ex;
    input [1:0]ALUSrcB_ex;
    input [31:0] Imm_ex;
    input [4:0]  rs1Addr_ex;
    input [4:0]  rs2Addr_ex;
    input [31:0] rs1Data_ex;
    input [31:0] rs2Data_ex;
	input [31:0] PC_ex;
    input [31:0] RegWriteData_wb;
    input [31:0] ALUResult_mem;
	input [4:0]rdAddr_mem;
    input [4:0] rdAddr_wb;
    input RegWrite_mem;
    input RegWrite_wb;
    output [31:0] ALUResult_ex;
    output [31:0] MemWriteData_ex;
    output [31:0] ALU_A;
    output [31:0] ALU_B;

    //数据前推电路
    wire [1:0]ForwardA,ForwardB;
    assign ForwardA[0]=RegWrite_wb && (rdAddr_wb!=0) && (rdAddr_mem!=rs1Addr_ex) && (rdAddr_wb==rs1Addr_ex);
    assign ForwardA[1]=RegWrite_mem && (rdAddr_mem!=0) && (rdAddr_mem==rs1Addr_ex);
    assign ForwardB[0]=RegWrite_wb && (rdAddr_wb!=0) && (rdAddr_mem!=rs2Addr_ex) && (rdAddr_wb==rs2Addr_ex);
    assign ForwardB[1]=RegWrite_mem && (rdAddr_mem!=0) && (rdAddr_mem==rs2Addr_ex);
    //数据转发MUX结果
    reg [31:0] A,B;
    always @(*) begin
        if (ForwardA == 2'b00) begin
            A = rs1Data_ex;
        end
        else if (ForwardA == 2'b01) begin
            A = RegWriteData_wb;
        end
        else begin
            A = ALUResult_mem;
        end

        if (ForwardB == 2'b00) begin
            B = rs2Data_ex;
        end
        else if (ForwardB == 2'b01) begin
            B = RegWriteData_wb;
        end
        else begin
            B = ALUResult_mem;
        end
    end

    // ALU操作数MUX
    reg [31:0] ALU_B_reg;
    assign ALU_A = ALUSrcA_ex ? PC_ex : A;
    always @(*) begin
        if (ALUSrcB_ex == 2'b00) begin
            ALU_B_reg = B;
        end
        else if (ALUSrcB_ex == 2'b01) begin
            ALU_B_reg = Imm_ex;
        end
        else begin
            ALU_B_reg = 32'h00000004;
        end
    end
    assign ALU_B=ALU_B_reg;
    assign MemWriteData_ex=B;//MemWriteData_ex输出
    //实例化ALU
    ALU ALU_inst(
        .ALUCode(ALUCode_ex),
        .A(ALU_A),
        .B(ALU_B),
        .ALUResult(ALUResult_ex)
    );
    

endmodule

\end{lstlisting}




\subsubsection*{\Large 仿真结果}
\normalsize

EX模块较为复杂，最后在CPU顶层模块中进行整体测试。

\newpage






%——————————————————————————————————————6

\subsection{IF模块}
\subsubsection*{\Large 设计原理}
\normalsize

IF 模块由指令指针寄存器（PC）、指令存储器子模块（Instruction ROM）、指令指针选择器（MUX）
和一个32 位加法器组成，IF 模块接口信息如图所示。

     \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{figures/fig/image14.png}
        \caption{IF 模块接口信息}
    \end{figure}

指令存储器为组合存储器，可用Verilog HDL 设计一个查找表阵列ROM。考虑到
FPGA 的资源，该ROM 容量可设计为64×32bit

指令存储器模块InstructionROM.v已经提供，只需在顶层模块中实例化即可。
内存放一段简单测试程序的机器码，对应的测试程序为：
\begin{lstlisting}[language=Verilog,caption=BranchTest仿真文件]
          lui X30, 0x3000
          jalr X31, later(X0)
earlier:sw X28, 0x0C(X0)
          lw X29, 4(X6)
          slliX5, X29, 2 //数据冒险
          lw X28, 4(X6)
          sltuX28,X6,X7
done:jal X31, done
          later: bneX0, X0, end // 分支条件不成立
          addi X5, X30, 0x42
          add X6, X0, X31
          sub X7, X5, X6 //操作A 二阶数据相关，操作B 一阶数据相关
          or X28, X7, X5 //操作A 一阶数据相关，操作B 三阶数据相关
          beq X0, X0, earlier // 分支条件成立
end: nop
\end{lstlisting}

\newpage


\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize
     \begin{figure}[H]
        \centering
        \includegraphics[width=0.75\textwidth]{figures/fig/image15.png}
        \caption{IF 模块结构图}
    \end{figure}

    根据上面的结构图，我们可以编写Verilog HDL代码如下：

\begin{enumerate}
    \item \textbf{输入输出信号}：
    \begin{itemize}
        \item \texttt{clk}：系统时钟信号。
        \item \texttt{reset}：系统复位信号，高电平有效。
        \item \texttt{Branch}：条件分支指令的条件判断结果。
        \item \texttt{Jump}：无条件分支指令的条件判断结果。
        \item \texttt{IFWrite}：流水线阻塞信号。
        \item \texttt{JumpAddr}：分支地址。
        \item \texttt{Instruction\_if}：取指令。
        \item \texttt{PC}：程序计数器。
        \item \texttt{IF\_flush}：指示是否需要刷新指令。
    \end{itemize}

    \item \textbf{PC寄存器}：
    \begin{itemize}
        \item 使用 \texttt{reg [31:0] PC\_in, PC\_out} 定义PC寄存器。
        \item \texttt{PCSoure} 信号用于选择PC的来源，\texttt{PCSoure} 为高时选择 \texttt{JumpAddr}，否则选择 \texttt{PC + 4}。
        \item 在时钟上升沿时，根据 \texttt{reset} 和 \texttt{IFWrite} 信号更新 \texttt{PC\_out} 的值。
    \end{itemize}

    \item \textbf{InstructionROM}：
    \begin{itemize}
        \item 实例化 \texttt{InstructionROM} 模块，用于从指令存储器中读取指令。
        \item 将 \texttt{PC[7:2]} 作为地址输入，读取的指令输出到 \texttt{Instruction\_if}。
    \end{itemize}
\end{enumerate}

\begin{lstlisting}[language=Verilog,caption=BranchTest仿真文件]
module IF1(clk, reset, Branch,Jump, IFWrite, JumpAddr,Instruction_if,PC,IF_flush);
    input clk;//系统时钟
    input reset;//系统复位信号，高电平有效
    input Branch;//条件分支指令的条件判断结果
    input Jump;//无条件分支指令的条件判断结果
    input IFWrite;//流水线阻塞信号
    input [31:0] JumpAddr;//分支地址
    output [31:0] Instruction_if;
    output [31:0] PC;
    output IF_flush;

    // PC寄存器
    reg [31:0] PC_in, PC_out;
    wire PCSoure;
    assign PCSoure = Jump || Branch;
    assign IF_flush=PCSoure;
    // 计算PC_in的值
    always @(*) begin
        if (PCSoure) begin
            PC_in = JumpAddr;
        end else begin
            PC_in = PC + 32'h00000004;
        end
    end
    // 在时钟上升沿时触发
    always @(posedge clk) begin
        if (reset) begin
            PC_out <= 32'b0; // 复位时将PC值重置为0
        end else if (IFWrite) begin
            PC_out <= PC_in; // 使能信号有效时更新PC值
        end else begin
            PC_out <= PC_out; // 使能信号无效时保持PC值不变
        end
    end
    assign PC = PC_out;
    //InstructionROM
    InstructionROM InstructionROM_ints(
        .addr(PC[7:2]),
        .dout(Instruction_if)
    );
endmodule
\end{lstlisting}



\newpage


\subsubsection*{\Large 仿真结果}
\normalsize
自己写了一段仿真文件进行模块测试,如下
\begin{lstlisting}[language=Verilog,caption=IF模块仿真文件]
	initial begin
		$dumpfile("IF.vcd");
 		$dumpvars;
		// Initialize Inputs
		clk = 0;
		reset = 1;
		Branch = 0; Jump = 0;
		IFWrite = 1;
		JumpAddr = 32'd20;
		
		// Wait 100 ns for global reset to finish
		#100 reset=0;

		// Add stimulus here
		#800 Branch = 1; Jump = 0;
		#100 Branch = 0; Jump = 0;
		#600 Branch = 0; Jump = 1; JumpAddr = 32'd40;
		#100 Branch = 0; Jump = 0;
		#200 IFWrite = 0;
		#400 $finish;	
	end
\end{lstlisting}


    具体仿真结果如下图所示。对照测试文件，仿真结果正确。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim6.png}
        \caption{仿真结果}
    \end{figure}

\newpage
%——————————————————————————————————————7

\subsection{MEM模块}
\subsubsection*{\Large 设计原理}
\normalsize

\textbf{MEM模块包括数据存储器子模块（Data RAM）和一些外围信号与选择电路。}

\subsubsection*{数据存储器IP内核生成}


数据存储器可用 Xilinx 的 IP 内核实现。考虑到 FPGA 的资源，数据存储器可设计为容量为 64×32 bit
的单端口 RAM，输出采用组合输出（Non Registered）。

如图，直接在vivado工程中，通过IP Catalog，选择RAM，并设置参数，生成IP核。
参数选择32位宽，64个存储单元，single port RAM ,non registered输出。

之后，直接在CPU顶层模块中实例化数据存储器模块即可。


    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image16.png}
        \caption{数据存储器IP内核生成}
    \end{figure}


    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image17.png}
        \caption{数据存储器IP内核生成}
    \end{figure}

\subsubsection*{MEM模块设计}

MEM模块较为简单，直接参考原理图，最后在CPU顶层模块中实现即可。

\newpage


%——————————————————————————————————————8



\subsection{流水线寄存器设计}



\subsubsection*{\Large 设计原理}
\normalsize
流水线寄存器负责将流水线的各部分分开，共有 IF/ID、ID/EX、EX/MEM、MEM/WB 四组，对四组
流水线寄存器要求不完全相同，因此设计也有不同考虑。
EX/MEM、MEM/WB 两组流水线寄存器只是普通的 D 型寄存器。
当流水线发生数据冒险时，需要清空 ID/EX 流水线寄存器而插入一个气泡，因此 ID/EX 流水线寄存
器是一个带同步清零功能的 D 型寄存器。
当流水线发生数据冒险时，需要阻塞 IF/ID 流水线寄存器；若跳转指令或分支成立，则还需要清空
ID/EX 流水线寄存器。因此，IF/ID 流水线寄存器除同步清零功能外，还需要具有保持功能（即具有使能
EN 信号输入）。

\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize

\begin{enumerate}
    \item \textbf{IF/ID寄存器模块}：
    \begin{itemize}
        \item 输入信号包括时钟、复位、使能、指令和PC值。
        \item 在时钟上升沿时，根据复位和使能信号更新输出指令和PC值。
    \end{itemize}

    \item \textbf{ID/EX寄存器模块}：
    \begin{itemize}
        \item 输入信号包括时钟、复位、PC值、源寄存器数据、立即数、寄存器地址和控制信号。
        \item 在时钟上升沿时，根据复位信号更新输出信号。
    \end{itemize}

    \item \textbf{EX/MEM寄存器模块}：
    \begin{itemize}
        \item 输入信号包括时钟、内存写信号、寄存器写信号、内存到寄存器信号、ALU计算结果、内存数据和寄存器地址。
        \item 在时钟上升沿时更新输出信号。
    \end{itemize}

    \item \textbf{MEM/WB寄存器模块}：
    \begin{itemize}
        \item 输入信号包括时钟、寄存器写信号、内存到寄存器信号、ALU计算结果、内存数据和寄存器地址。
        \item 在时钟上升沿时更新输出信号。
    \end{itemize}
\end{enumerate}


\begin{lstlisting}[language=Verilog,caption=各级流水线寄存器]
// IFID寄存器模块
module IF_ID (
    input clk,                // 时钟信号
    input reset,              // 复位信号，高电平有效
    input EN,                 // 使能信号
    input [31:0] Instruction_if, // 输入指令
    input [31:0] PC_if,       // 输入PC值
    output reg [31:0] Instruction_id, // 输出指令
    output reg [31:0] PC_id   // 输出PC值
);

    // 在时钟上升沿时触发
    always @(posedge clk) begin
        if (reset) begin
            Instruction_id <= 32'b0; // 复位
            PC_id <= 32'b0;          
        end else if (EN) begin
            Instruction_id <= Instruction_if; // 使能信号有效时更新
            PC_id <= PC_if;                   
        end else begin
            Instruction_id <= Instruction_id; // 使能信号无效时保持
            PC_id <= PC_id;                  
        end
    end

endmodule

//IDEX寄存器模块
module ID_EX (
    input clk,                // 时钟信号
    input reset,              // 复位信号，高电平有效
    input [31:0] PC_id,       // 输入PC值
    input [31:0] rs1Data_id,  // 输入源寄存器1数据
    input [31:0] rs2Data_id,  // 输入源寄存器2数据
    input [31:0] Imm_id,      // 输入立即数
    input [4:0] rdAddr_id,        // 输入目的寄存器地址
    input [4:0] rs1Addr_id,       // 输入源寄存器1地址
    input [4:0] rs2Addr_id,       // 输入源寄存器2地址
    input [3:0] ALUCode_id,   // 输入ALU控制信号
    input ALUSrcA_id,         // 输入ALU源操作数A选择信号
    input [1:0] ALUSrcB_id,   // 输入ALU源操作数B选择信号
    input MemRead_id,         // 输入内存读信号
    input MemWrite_id,        // 输入内存写信号
    input RegWrite_id,        // 输入寄存器写信号
    input MemtoReg_id,  // 输入内存到寄存器信号


    output reg [31:0] PC_ex,          // 输出PC值
    output reg [31:0] rs1Data_ex,     // 输出源寄存器1数据
    output reg [31:0] rs2Data_ex,     // 输出源寄存器2数据
    output reg [31:0] Imm_ex,         // 输出立即数
    output reg [4:0] rdAddr_ex,           // 输出目的寄存器地址
    output reg [4:0] rs1Addr_ex,          // 输出源寄存器1地址
    output reg [4:0] rs2Addr_ex,          // 输出源寄存器2地址
    output reg [3:0] ALUCode_ex,      // 输出ALU控制信号
    output reg ALUSrcA_ex,            // 输出ALU源操作数A选择信号
    output reg [1:0] ALUSrcB_ex,      // 输出ALU源操作数B选择信号
    output reg MemRead_ex,            // 输出内存读信号
    output reg MemWrite_ex,           // 输出内存写信号
    output reg RegWrite_ex,           // 输出寄存器写信号
    output reg MemtoReg_ex      // 输出内存到寄存器信号
);

    // 在时钟上升沿时触发
    always @(posedge clk) begin
        if (reset) begin
            PC_ex <= 32'b0;          // 复位
            rs1Data_ex <= 32'b0;     
            rs2Data_ex <= 32'b0;     
            Imm_ex <= 32'b0;        
            rdAddr_ex <= 5'b0;       
            rs1Addr_ex <= 5'b0;      
            rs2Addr_ex <= 5'b0;     
            ALUCode_ex <= 4'b0;      
            ALUSrcA_ex <= 1'b0;     
            ALUSrcB_ex <= 2'b0;    
            MemRead_ex <= 1'b0;      
            MemWrite_ex <= 1'b0;   
            RegWrite_ex <= 1'b0;     
            MemtoReg_ex <= 1'b0;     
        end else begin
            PC_ex <= PC_id;          // 更新
            rs1Data_ex <= rs1Data_id; 
            rs2Data_ex <= rs2Data_id; 
            Imm_ex <= Imm_id;         
            rdAddr_ex <= rdAddr_id;  
            rs1Addr_ex <= rs1Addr_id;
            rs2Addr_ex <= rs2Addr_id; 
            ALUCode_ex <= ALUCode_id;
            ALUSrcA_ex <= ALUSrcA_id;
            ALUSrcB_ex <= ALUSrcB_id; 
            MemRead_ex <= MemRead_id;
            MemWrite_ex <= MemWrite_id; 
            RegWrite_ex <= RegWrite_id; 
            MemtoReg_ex <= MemtoReg_id;
        end
    end

endmodule


// EXMEM寄存器模块
module EX_MEM (
    input clk,                // 时钟信号
    input MemWrite_ex,        // 输入内存写信号
    input RegWrite_ex,        // 输入寄存器写信号
    input MemtoReg_ex,        // 输入内存到寄存器信号
    input [31:0] ALUResult_ex,// 输入ALU计算结果
    input [31:0] MemWriteData_ex, // 输入内存数据
    input [4:0] rdAddr_ex,    // 输入目的寄存器地址

    output reg MemWrite_mem,  // 输出内存写信号
    output reg RegWrite_mem,  // 输出寄存器写信号
    output reg MemtoReg_mem,  // 输出内存到寄存器信号
    output reg [31:0] ALUResult_mem, // 输出ALU计算结果
    output reg [31:0] MemWriteData_mem, // 输出内存数据
    output reg [4:0] rdAddr_mem // 输出目的寄存器地址
);

    // 在时钟上升沿时触发
    always @(posedge clk) begin
        MemWrite_mem <= MemWrite_ex;       // 更新
        RegWrite_mem <= RegWrite_ex;       
        MemtoReg_mem <= MemtoReg_ex;       
        ALUResult_mem <= ALUResult_ex;    
        MemWriteData_mem <= MemWriteData_ex; 
        rdAddr_mem <= rdAddr_ex;        
    end

endmodule

// MEMWB寄存器模块
module MEM_WB (
    input clk,                // 时钟信号
    input RegWrite_mem,       // 输入寄存器写信号
    input MemtoReg_mem,       // 输入内存到寄存器信号
    input [31:0] ALUResult_mem, // 输入ALU计算结果
    input [31:0] MemDout_mem, // 输入内存数据
    input [4:0] rdAddr_mem,   // 输入目的寄存器地址

    output reg RegWrite_wb,   // 输出寄存器写信号
    output reg MemtoReg_wb,   // 输出内存到寄存器信号
    output reg [31:0] ALUResult_wb, // 输出ALU计算结果
    output reg [31:0] MemDout_wb, // 输出内存数据
    output reg [4:0] rdAddr_wb // 输出目的寄存器地址
);

    // 在时钟上升沿时触发
    always @(posedge clk) begin
        RegWrite_wb <= RegWrite_mem;       // 更新
        MemtoReg_wb <= MemtoReg_mem;       
        ALUResult_wb <= ALUResult_mem;     
        MemDout_wb <= MemDout_mem;         
        rdAddr_wb <= rdAddr_mem;           
    end

endmodule
\end{lstlisting}

%——————————————————————————————————————9

\newpage

\subsection{CPU顶层模块}
\subsubsection*{\Large 设计原理}
\normalsize

按照原理框图连接各模块即可。为了测试方便，可将关键变量输出，关键变量有：指
令指针 PC、指令码 Instruction\_id、流水线插入气泡标志 Stall、分支标志 JumpFlag 即{Jump, Branch}、ALU
输入输出（ALU\_A、ALU\_B、ALUResult\_ex）和数据存储器的输出 MemDout\_mem。

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image18.png}
        \caption{CPU顶层模块结构图}
    \end{figure}

\newpage

\subsubsection*{\Large Verilog HDL代码与设计分析}
\normalsize

CPU顶层模块主要是将各个模块连接起来，同时输出关键变量，方便测试，直接根据原理图从左到右连接各个模块即可。


\begin{lstlisting}[language=Verilog,caption=CPU顶层模块]
module Risc5CPU(clk, reset, JumpFlag, Instruction_id, ALU_A, 
                     ALU_B, ALUResult_ex, PC, MemDout_mem,Stall,Imm_id_test,Imm_ex_test,ALUSrcB_ex_test);
    input clk;
    input reset;//PC寄存器的复位信号
    output[1:0] JumpFlag;
    output [31:0] Instruction_id;
    output [31:0] ALU_A;
    output [31:0] ALU_B;
    output [31:0] ALUResult_ex;
    output [31:0] PC;
    output [31:0] MemDout_mem;
    output Stall;

    //测试output
    output [31:0]Imm_id_test,Imm_ex_test;
    output [1:0]ALUSrcB_ex_test;

    //IF模块
    wire Branch,Jump,IFWrite,IF_flush;
    wire [31:0] JumpAddr,Instruction_if;
    assign JumpFlag[1]=Jump;
    assign JumpFlag[0]=Branch;
    // wire [31:0] PC;//已经在顶层定义

    IF1 IF1_ints(
        .clk(clk),
        .reset(reset),
        .Branch(Branch),
        .Jump(Jump),
        .IFWrite(IFWrite),
        .JumpAddr(JumpAddr),
        .Instruction_if(Instruction_if),
        .PC(PC),
        .IF_flush(IF_flush)
    );

    //IFID寄存器
    wire [31:0] PC_id;
    // wire [31:0] Instruction_id;//已经在顶层定义
    IF_ID IF_ID_ints(
        .clk(clk),
        .reset(IF_flush),
        .EN(IFWrite),
        .Instruction_if(Instruction_if),
        .PC_if(PC),
        .Instruction_id(Instruction_id),
        .PC_id(PC_id)
    );

    //ID模块
    //输入信号
    wire RegWrite_wb;
    wire [4:0] rdAddr_wb;
    wire [31:0] RegWriteData_wb;
    wire MemRead_ex;
    wire [4:0] rdAddr_ex;
    //输出信号
    wire MemtoReg_id;
    wire RegWrite_id;
    wire MemWrite_id;
    wire MemRead_id;
    wire [3:0] ALUCode_id;
    wire ALUSrcA_id;
    wire [1:0]ALUSrcB_id;
    // wire Stall;//已经在顶层定义
    wire [31:0] Imm_id;
    wire [31:0] rs1Data_id;
    wire [31:0] rs2Data_id;
    wire[4:0] rs1Addr_id,rs2Addr_id,rdAddr_id;

    ID ID_inst(
        .clk(clk),
        .Instruction_id(Instruction_id),
        .PC_id(PC_id),
        .RegWrite_wb(RegWrite_wb),
        .rdAddr_wb(rdAddr_wb),
        .RegWriteData_wb(RegWriteData_wb),
        .MemRead_ex(MemRead_ex),
        .rdAddr_ex(rdAddr_ex),
        .MemtoReg_id(MemtoReg_id),
        .RegWrite_id(RegWrite_id),
        .MemWrite_id(MemWrite_id),
        .MemRead_id(MemRead_id),
        .ALUCode_id(ALUCode_id),
        .ALUSrcA_id(ALUSrcA_id),
        .ALUSrcB_id(ALUSrcB_id),
        .Stall(Stall),
        .Branch(Branch),
        .Jump(Jump),
        .IFWrite(IFWrite),
        .JumpAddr(JumpAddr),
        .Imm_id(Imm_id),
        .rs1Data_id(rs1Data_id),
        .rs2Data_id(rs2Data_id),
        .rs1Addr_id(rs1Addr_id),
        .rs2Addr_id(rs2Addr_id),
        .rdAddr_id(rdAddr_id)
    );

    //IDEX寄存器
    wire [31:0] PC_ex;
    wire [31:0] rs1Data_ex;
    wire [31:0] rs2Data_ex;
    wire [31:0] Imm_ex;
    // wire [4:0] rdAddr_ex;//已经在ID模块定义
    wire [4:0] rs1Addr_ex;
    wire [4:0] rs2Addr_ex;
    wire [3:0] ALUCode_ex;
    wire ALUSrcA_ex;
    wire [1:0] ALUSrcB_ex;
    // wire MemRead_ex;//已经在ID模块定义
    wire MemWrite_ex;
    wire RegWrite_ex;
    wire MemtoReg_ex;

    ID_EX ID_EX_inst(
        .clk(clk),
        .reset(reset),
        .PC_id(PC_id),
        .rs1Data_id(rs1Data_id),
        .rs2Data_id(rs2Data_id),
        .Imm_id(Imm_id),
        .rdAddr_id(rdAddr_id),
        .rs1Addr_id(rs1Addr_id),
        .rs2Addr_id(rs2Addr_id),
        .ALUCode_id(ALUCode_id),
        .ALUSrcA_id(ALUSrcA_id),
        .ALUSrcB_id(ALUSrcB_id),
        .MemRead_id(MemRead_id),
        .MemWrite_id(MemWrite_id),
        .RegWrite_id(RegWrite_id),
        .MemtoReg_id(MemtoReg_id),
        .PC_ex(PC_ex),
        .rs1Data_ex(rs1Data_ex),
        .rs2Data_ex(rs2Data_ex),
        .Imm_ex(Imm_ex),
        .rdAddr_ex(rdAddr_ex),
        .rs1Addr_ex(rs1Addr_ex),
        .rs2Addr_ex(rs2Addr_ex),
        .ALUCode_ex(ALUCode_ex),
        .ALUSrcA_ex(ALUSrcA_ex),
        .ALUSrcB_ex(ALUSrcB_ex),
        .MemRead_ex(MemRead_ex),
        .MemWrite_ex(MemWrite_ex),
        .RegWrite_ex(RegWrite_ex),
        .MemtoReg_ex(MemtoReg_ex)
    );

    //EX模块
    // wire [31:0] ALUResult_ex;//已经在顶层定义
    wire [31:0] MemWriteData_ex;
    // wire [31:0] ALU_A;//已经在顶层定义
    // wire [31:0] ALU_B;//已经在顶层定义
    // wire [31:0] RegWriteData_wb;//已经在ID模块定义
    wire [31:0] ALUResult_mem;
    wire [4:0] rdAddr_mem;
    // wire [4:0] rdAddr_wb;//已经在ID模块定义
    wire RegWrite_mem;
    // wire RegWrite_wb;//已经在ID模块定义

    EX EX_inst(
        .ALUCode_ex(ALUCode_ex),
        .ALUSrcA_ex(ALUSrcA_ex),
        .ALUSrcB_ex(ALUSrcB_ex),
        .Imm_ex(Imm_ex),
        .rs1Addr_ex(rs1Addr_ex),
        .rs2Addr_ex(rs2Addr_ex),
        .rs1Data_ex(rs1Data_ex),
        .rs2Data_ex(rs2Data_ex),
        .PC_ex(PC_ex),
        .RegWriteData_wb(RegWriteData_wb),
        .ALUResult_mem(ALUResult_mem),
        .rdAddr_mem(rdAddr_mem),
        .rdAddr_wb(rdAddr_wb),
        .RegWrite_mem(RegWrite_mem),
        .RegWrite_wb(RegWrite_wb),
        .ALUResult_ex(ALUResult_ex),
        .MemWriteData_ex(MemWriteData_ex),
        .ALU_A(ALU_A),
        .ALU_B(ALU_B)
    );

    //EXMEM寄存器
    wire MemWrite_mem;
    // wire RegWrite_mem;//已经在EX模块定义
    wire MemtoReg_mem;
    // wire [31:0] ALUResult_mem;//已经在EX模块定义
    wire [31:0] MemWriteData_mem;
    // wire [4:0] rdAddr_mem;//已经在EX模块定义

    EX_MEM EX_MEM_inst(
        .clk(clk),
        .MemWrite_ex(MemWrite_ex),
        .RegWrite_ex(RegWrite_ex),
        .MemtoReg_ex(MemtoReg_ex),
        .ALUResult_ex(ALUResult_ex),
        .MemWriteData_ex(MemWriteData_ex),
        .rdAddr_ex(rdAddr_ex),
        .MemWrite_mem(MemWrite_mem),
        .RegWrite_mem(RegWrite_mem),
        .MemtoReg_mem(MemtoReg_mem),
        .ALUResult_mem(ALUResult_mem),
        .MemWriteData_mem(MemWriteData_mem),
        .rdAddr_mem(rdAddr_mem)
    );

    //MEM模块
    wire [31:0] MemDout_mem;
    DataRAM DataRAM_inst(
        .a(ALUResult_mem[7:2]),
        .d(MemWriteData_mem),
        .clk(clk),
        .we(MemWrite_mem),
        .spo(MemDout_mem)
    );

    //MEMWB寄存器
    // wire RegWrite_wb;//已经在ID模块定义
    wire MemtoReg_wb;
    wire [31:0] ALUResult_wb;
    wire [31:0 ]MemDout_wb;
    // wire [4:0] rdAddr_wb;//已经在ID模块定义

    MEM_WB MEM_WB_inst(
        .clk(clk),
        .RegWrite_mem(RegWrite_mem),
        .MemtoReg_mem(MemtoReg_mem),
        .ALUResult_mem(ALUResult_mem),
        .MemDout_mem(MemDout_mem),
        .rdAddr_mem(rdAddr_mem),
        .RegWrite_wb(RegWrite_wb),
        .MemtoReg_wb(MemtoReg_wb),
        .ALUResult_wb(ALUResult_wb),
        .MemDout_wb(MemDout_wb),
        .rdAddr_wb(rdAddr_wb)
    );

    //WB模块
    assign RegWriteData_wb=MemtoReg_wb?MemDout_wb:ALUResult_wb;

    //测试信号赋值
    assign Imm_id_test=Imm_id;
    assign ALUSrcB_ex_test=ALUSrcB_ex;
    assign Imm_ex_test=Imm_ex;
endmodule

\end{lstlisting}

\newpage


\subsubsection*{\Large 仿真结果}
\normalsize
使用如下的代码进行仿真测试，CPU将会运行instructionsROM中的指令，将仿真得到的信号值与预期值进行比较，以验证CPU的正确性。
\begin{lstlisting}[language=Verilog,caption=CPU 仿真文件]
	initial 
	   begin
		// Initialize Inputs
		clk = 0;
		reset = 1;
         // Wait 100 ns for global reset to finish
        #100
	    #51 reset=0;
     	#2200 $finish;
	   end
	
	always #20 clk=~clk;
\end{lstlisting}


    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim7.png}
    \end{figure}
        \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim8.png}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim9.png}
        \caption{CPU行为级仿真结果}
    \end{figure}

    将仿真得到的信号值与下图中的预期值进行比较，可以看到仿真结果正确。

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image1.png}
        \caption{CPU行为级仿真预期结果}
    \end{figure}
%——————————————————————————————————————10
\newpage


\section{实验结果}

再次打开 Vivado 文件夹下的 Risc5CPU.xpr 工程，添加流水线 CPU 设计的全部代码，然后综合、
实现和下载至 Nexys Video 开发板。

连接带有 HDMI 接口的显示器，进行测试。首先将 SW0 置于低电平，使 RISC-V CPU 工作在
“单步”运行模式。复位后，每按一下上边按键，RISC-V CPU 运行一步，记录下显示器上的结果，对照
CPU行为级仿真预期结果验证设计是否正确

\begin{figure}[H]
    \centering
    \begin{minipage}[b]{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/fig/fram1.png}
    \end{minipage}
    \begin{minipage}[b]{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/fig/fram2.png}
    \end{minipage}
    \begin{minipage}[b]{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/fig/fram3.png}
    \end{minipage}
    \begin{minipage}[b]{0.24\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/fig/fram4.png}
    \end{minipage}
\end{figure}


\newpage


\section{拓展部分}
\subsubsection*{\Large 拓展1：要求设计的微处理器还能运行 lb、lh、ld、lbu、lhu、lwu、sb、sh 或 sd 等字节、半字和双字数
据传送指令}
\normalsize

由于本设计的CPU为32位，因此不支持双字数据传送指令ld和sd，但是可以通过修改指令集，增加支持字节、半字和双字数据传送指令的指令，如下所示：

\begin{itemize}
    \item 首先在decode模块中增加新的指令译码信号如下图：
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image19.png}
        \caption{decode模块增加新的指令译码信号}
    \end{figure}
    \item 修改ID模块，增加新的指令译码信号
        \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image20.png}
        \caption{ID模块增加新的指令译码信号}
    \end{figure}
    \item 然后修改pipeline寄存器，增加新的指令译码信号
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image22.png}
        \caption{pipeline寄存器增加新的指令译码信号}
    \end{figure}
    \item 新增加一个MEM模块，在MEM模块根据指令译码信号选择对应的数据传送操作
    \begin{lstlisting}
        module MEM (
    input [31:0] ALUResult_mem, // 输入ALU计算结果
    input [31:0] MemWriteData_mem, // 输入内存数据
    input clk,            // 时钟输入
    input MemWrite_mem,   // 写使能输入
    input [2:0] LWCode_mem, // 输入LW指令控制信号
    input [1:0] SWCode_mem, // 输入SW指令控制信号
    output [31:0] MemDout_mem // 数据输出
);  
    wire [31:0] MemDout_mem_wire;
    reg [31:0] MemDout_mem_reg;
    reg [31:0] d_reg;
    //根据SWCode_mem选择写入的数据00:sb 01:sh 10:sw
    always @(*) begin
        if (SWCode_mem == 2'b00) begin
            d_reg = {24'b0, MemWriteData_mem[7:0]};
        end
        else if (SWCode_mem == 2'b01) begin
            d_reg = {16'b0, MemWriteData_mem[15:0]};
        end
        else begin
            d_reg = MemWriteData_mem;
        end
    end

    DataRAM DataRAM_inst(
        .a(ALUResult_mem[7:2]),
        .d(d_reg),
        .clk(clk),
        .we(MemWrite_mem),
        .spo(MemDout_mem_wire)
    );
    //根据LWCode_mem选择读出的数据000:lb 001:lh 010:lw 100:lbu 101:lhu
    always @(*) begin
        if (LWCode_mem == 3'b000) begin
            MemDout_mem_reg = {{24{MemDout_mem_wire[7]}}, MemDout_mem_wire[7:0]};
        end
        else if (LWCode_mem == 3'b001) begin
            MemDout_mem_reg = {{16{MemDout_mem_wire[15]}}, MemDout_mem_wire[15:0]};
        end
        else if (LWCode_mem == 3'b100) begin
            MemDout_mem_reg = {24'b0, MemDout_mem_wire[7:0]};
        end
        else if (LWCode_mem == 3'b101) begin
            MemDout_mem_reg = {16'b0, MemDout_mem_wire[15:0]};
        end
        else begin
            MemDout_mem_reg = MemDout_mem_wire;
        end
    end
    assign MemDout_mem = MemDout_mem_reg;


endmodule
    \end{lstlisting}
    \item 最后在CPU顶层模块中增加新的信号和模块，重新连接各个模块即可。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image23.png}
        \caption{CPU顶层模块增加新的信号和模块}
    \end{figure}
\end{itemize}


\subsubsection*{\Large 仿真测试}
\normalsize

首先修改InstructionROM中的指令集，增加支持字节、半字和双字数据传送指令的指令，如下所示：

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image21.png}
        \caption{InstructionROM中的指令集}
    \end{figure}

然后使用相同的仿真文件进行仿真测试，可以看到仿真结果如下.
当前测试的是lh和lhu，PC=0x0C时执行lh指令加载x29中的0xFFFFA0BA。
PC=0x14时执行lhu指令加载x29中的0xFFFFA0BA。
关注MemDout\_mem，1.7us和2.0us时MemDout\_mem分别为0xFFFFA0BA和0x0000A0BA，说明lh和lhu指令执行正确。

其它指令同理进行仿真测试，不一一列举，最终结果正确。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim10.png}
        \caption{CPU行为级仿真结果}
    \end{figure}

\subsubsection*{\Large 拓展2：要求设计的 CPU 增加异常（exception）、自陷（trap）、中断（interrupt）等处理方案}
\normalsize
\textbf{由于中断涉及到PLIC中断控制器，异常和自陷涉及到异常处理单元和操作系统，还需要考虑处理器运行在用户态和内核态的切换等内容，远远超出了本次实验的范围。}

\textbf{因此没有给出具体的Verilog代码实现，仅仅给出了设计思路。}

\subsubsection*{中断处理方案}
\normalsize

硬件部分主要包括中断源、中断控制器（PLIC）、中断控制器和CPU之间的接口等
软件部分主要包括中断向量表、中断服务程序（ISR）等，以及操作系统内核中对中断处理的支持。
\begin{enumerate}
    \item \textbf{中断源}：
    \begin{itemize}
        \item 中断源可以是外部设备（如键盘、鼠标、网络接口等）或内部事件（如定时器中断、软件中断等）。
        \item 每个中断源都有一个唯一的中断请求信号，当中断事件发生时，该信号被置高。
    \end{itemize}

    \item \textbf{中断控制器（PLIC）}：
    \begin{itemize}
        \item 中断控制器用于管理和优先级排序多个中断请求。
        \item 当一个或多个中断请求发生时，中断控制器根据中断优先级选择一个中断请求，并向处理器发送中断信号。
        \item 中断控制器还负责中断屏蔽和中断向量的管理。
    \end{itemize}

    \item \textbf{中断向量表}：
    \begin{itemize}
        \item 中断向量表是一个存储器区域，用于存储每个中断源对应的中断服务程序的入口地址。
        \item 当中断发生时，处理器根据中断向量表找到对应的中断服务程序的入口地址，并跳转到该地址执行中断服务程序。
    \end{itemize}

    \item \textbf{中断服务程序（ISR）}：
    \begin{itemize}
        \item 中断服务程序是处理中断事件的代码，当中断发生时，处理器会跳转到对应的中断服务程序执行。
        \item 中断服务程序应该在软件上实现
        \begin{enumerate}
            \item 保存当前处理器状态（如寄存器值、程序计数器等）。
            \item 处理中断事件（如读取设备数据、清除中断请求等）。
            \item 恢复处理器状态，返回中断前的执行位置。
        \end{enumerate}
    \end{itemize}

    \item \textbf{中断处理流程}：
    \begin{itemize}
        \item 当中断请求发生时，中断控制器向处理器发送中断信号。
        \item 处理器响应中断信号，保存当前处理器状态，并根据中断向量表找到对应的中断服务程序入口地址。
        \item 处理器跳转到中断服务程序入口地址，执行中断服务程序。
        \item 中断服务程序处理完中断事件后，恢复处理器状态，返回中断前的执行位置。
    \end{itemize}
\end{enumerate}

\textbf{另外}：中断处理方案的设计需要考虑中断优先级、中断嵌套、中断屏蔽等问题，以确保系统能够正确、高效地处理中断事件。


\subsubsection*{异常处理方案}
\normalsize

异常处理方案主要包括异常类型、异常向量表、异常处理程序等。
硬件上主要要考虑硬件异常，如非法指令、系统调用、内存访问错误、中断等。以及这些异常触发
信号如何传递给异常处理单元，异常处理单元与CPU之间的接口等。
另外如果涉及到虚拟内存相关的异常处理如page fault，还需要考虑MMU等虚拟内存相关的硬件单元。

此外，硬件上还需要加入各种特殊寄存器，如EPC（Exception Program Counter）、CAUSE（Cause）等，用于支持中断和内核态切换等。


软件上，主要要考虑异常向量表、异常处理程序等，以及操作系统内核中对异常处理的支持。

\begin{enumerate}
    \item \textbf{异常类型}：
    \begin{itemize}
        \item 异常类型包括非法指令、系统调用、内存访问错误、中断等。
        \item 每种异常类型都有一个唯一的异常码，用于标识异常类型。
    \end{itemize}

    \item \textbf{异常向量表}：
    \begin{itemize}
        \item 异常向量表是一个存储器区域，用于存储每个异常类型对应的中断服务程序的入口地址。
        \item 当异常发生时，处理器根据异常向量表找到对应的中断服务程序的入口地址，并跳转到该地址执行中断服务程序。
    \end{itemize}

    \item \textbf{异常处理程序}：
    \item 异常处理程序是处理异常事件的代码，当中断发生时，处理器会跳转到对应的中断服务程序执行。
    \item 异常处理程序应该在软件上实现
    \item 异常处理程序包括以下步骤：
    \item 保存当前处理器状态（如寄存器值、程序计数器等）。
    \item 处理异常事件（如读取设备数据、清除中断请求等）。
    \item 恢复处理器状态，返回中断前的执行位置。
\end{enumerate}

\subsubsection*{自陷处理方案}
\normalsize

Trap是一种同步事件，通常由程序指令主动触发，例如系统调用（syscall）或断点（breakpoint）。
Trap的处理流程与中断类似，主要包括以下步骤：
\begin{enumerate}
    \item Trap指令触发异常，处理器保存当前处理器状态，并根据异常向量表找到对应的中断服务程序入口地址。
    \item 处理器跳转到中断服务程序入口地址，执行中断服务程序。
    \item 中断服务程序处理完异常事件后，恢复处理器状态，返回中断前的执行位置。
\end{enumerate}
因此，自陷处理方案的设计主要软件上的内容。硬件上，需要加入Risc中的trap指令，以及trap指令触发异常后，CPU如何处理异常的硬件电路部分。同时还要加入各种特殊寄存器，如EPC（Exception Program Counter）、CAUSE（Cause）等，用于支持trap。

如操作系统内核中对自陷处理的支持，包括自陷指令的识别、自陷向量表、自陷处理程序等。


\newpage

\section{遇到的问题及解决}
在设计和实现流水线 RISC-V 微处理器的过程中，遇到了一些问题。以下是主要问题及其解决方案：

\subsection{问题1：测试仿真问题}

\textbf{描述}：在设计完成后，需要对 CPU 进行功能仿真和时序仿真，以验证设计的正确性和性能。然而，在仿真过程中，遇到了一些问题，例如仿真波形不符合预期、仿真时间过长等。

\textbf{解决方案}：
\begin{itemize}
    \item 编写详细的测试文件，对各个模块进行功能仿真，确保每个模块的功能正确。
    \item 使用 ModelSim 进行功能仿真，观察仿真波形，逐步排查问题，修正设计中的错误。
    \item 通过 Vivado 的仿真工具进行时序仿真，验证设计在实际硬件上的性能，确保时序满足要求。
    \item 优化仿真时间，通过减少仿真时间步长、简化测试用例等方法，提高仿真效率。
\end{itemize}

\subsection{问题2：开发环境问题}

\textbf{描述}：在开发过程中，遇到了一些开发环境相关的问题，例如vivado开发环境不方便、IP 核生成失败等。这些问题导致开发进度受到影响。

\textbf{解决方案}：
\begin{itemize}
    \item 配置vscode的轻量级开发和调试环境，方便代码编写和调试。
    \item 确保开发环境的正确配置，包括 Vivado 和 ModelSim 的安装和配置，确保工具链能够正常工作。
    \item 在 Vivado 中，通过 IP Catalog 选择合适的 IP 核，并正确设置参数，生成所需的 IP 核。
    \item 参考官方文档和社区资源，解决开发环境中的问题，例如工具链配置错误、IP 核生成失败等。
    \item 定期备份项目文件，防止因开发环境问题导致的数据丢失。
\end{itemize}

\subsection{问题3：拓展指令问题}

\textbf{描述}：在设计过程中，需要增加对字节、半字和双字数据传送指令的支持。然而，增加这些指令会导致指令译码和数据存储器的设计变得更加复杂。

\textbf{解决方案}：
\begin{itemize}
    \item 在 Decode 模块中，增加新的指令译码信号，支持 lb、lh、lbu、lhu 等指令。
    \item 修改 ID 模块，增加新的指令译码信号，确保新的指令能够正确译码。
    \item 修改流水线寄存器，增加新的指令译码信号，确保新的指令能够正确传递。
    \item 在 MEM 模块中，根据指令译码信号选择对应的数据传送操作，确保新的指令能够正确执行。
    \item 在 CPU 顶层模块中，增加新的信号和模块，重新连接各个模块，确保新的指令能够正确工作。
    \item 通过仿真测试，验证新的指令是否能够正确执行，确保设计的正确性。
\end{itemize}

通过以上方法，成功解决了设计和实现过程中遇到的问题，最终完成了流水线 RISC-V 微处理器的设计和实现。

\newpage

\section{思考题}

\textbf{如下面两条指令，条件分支指令试图读取上一条指令的目标寄存器，插入气泡或数据转发都无法解
决流水线冲突问题。为什么在大多 CPU 架构中，都不去解决这一问题？这一问题应在什么层面中解决？}
\begin{lstlisting}
    lw X28, 04(X6) 
    beq X28,x29,Loop
\end{lstlisting}

在上述指令中，`lw` 指令从内存中加载数据到寄存器 `X28`，而紧接着的 `beq` 指令需要使用 `X28` 的值进行条件判断。这种情况下，由于 `lw` 指令的结果还未写回寄存器，`beq` 指令无法立即获取到正确的 `X28` 值，从而导致数据冒险问题。

在大多数 CPU 架构中，通常不直接在硬件层面解决这种问题，原因如下：

\begin{enumerate}
    \item \textbf{硬件复杂度}：在硬件层面解决这种问题需要增加额外的逻辑电路来处理数据冒险，例如复杂的转发逻辑和流水线暂停机制。这会增加硬件设计的复杂度和成本。
    \item \textbf{性能影响}：即使在硬件层面解决了这种问题，也会导致流水线暂停，从而影响 CPU 的整体性能。频繁的流水线暂停会降低指令执行的效率。
    \item \textbf{编译器优化}：现代编译器可以通过指令调度和优化技术来避免这种数据冒险问题。例如，编译器可以在 `lw` 和 `beq` 指令之间插入其他无关指令，或者重新安排指令的顺序，以避免数据冒险。
    \item \textbf{软件层面解决}：这种问题通常在软件层面解决。程序员可以通过手动插入 `NOP` 指令（空操作指令）或重新安排指令顺序来避免数据冒险。此外，编译器也可以自动进行这种优化。
\end{enumerate}

综上所述，大多数 CPU 架构选择在软件层面解决这种数据冒险问题，而不是在硬件层面直接处理。这种方法不仅可以降低硬件设计的复杂度，还可以通过编译器优化和程序员的手动调整来提高指令执行的效率。

\textcolor{red}{拓展：为了研究如何在硬件上解决这个问题，本人在硬件层面上实现了该情境下的数据冒险的解决，通过插入气泡和转发来解决数据冒险问题，并进行了仿真测试，验证了设计的正确性，然而后果是增加了硬件的复杂度和过长的数据通路导致的时延增加和性能下降。}

具体的实现思路如下，我们考虑直接从EX阶段的ALU计算结果和MEM阶段的DataRAM输
出结果将数据转发到ID阶段，而不是从下一级的流水线寄存器中转发，这样可以提前
一个时钟周期，使得存储指令+跳转指令的冲突变得只需要一个时钟周期的气泡，
而不是两个时钟周期的气泡。
从而可以沿用之前的流水线中的数据转发和气泡插入的机制，而不需要做过多的修改。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image24.png}
        \caption{数据冒险解决方案}
    \end{figure}

\begin{itemize}
    \item 首先新增加一个BrForwarding电路，用于ID阶段处理Branch指令的数据冒险，将EX阶段的ALU计算结果和MEM阶段的DataRAM输出结果转发到ID阶段。
    \begin{lstlisting}
 //BrForwarding电路
//用于处理Branch指令的数据冒险
//Branch指令的数据冒险是由于Branch指令的执行需要用到前一条指令的结果
//而前一条指令的结果可能还没有计算出来，因此需要将前一条指令的结果提前计算出来
//然后传递给BranchTest模块

//输出：BrForwardA: 2'b00:rs1Data_id, 2'b01:ALUResult_ex, 2'b10:MemDout_mem, 2'b11:ALUResult_mem
//     BrForwardB: 2'b00:rs2Data_id, 2'b01:ALUResult_ex, 2'b10:MemDout_mem, 2'b11:ALUResult_mem

//一级转发，ALUResult_ex的结果转发到BranchTest模块
//条件：EX级写操作，目标寄存器不为0，两条指令的目标寄存器相同
// RegWrite_ex ==1 && rdAddr_ex != 5'b0 && rs1Addr_id==rdAddr_ex
// RegWrite_ex ==1 && rdAddr_ex != 5'b0 && rs2Addr_id==rdAddr_ex

//二级转发，MemDout_mem的结果或者ALUResult_mem结果转发到BranchTest模块
//条件：MEM级写操作，目标寄存器不为0，两条指令的目标寄存器相同，一级转发条件不满足rs1Addr_id!=rdAddr_ex
// RegWrite_mem ==1 && rdAddr_mem != 5'b0 && rs1Addr_id==rdAddr_mem && rs1Addr_id!=rdAddr_ex
// RegWrite_mem ==1 && rdAddr_mem != 5'b0 && rs2Addr_id==rdAddr_mem && rs2Addr_id!=rdAddr_ex
// 还要根据MemtoReg信号判断转发MemDout_mem还是ALUResult_mem

//lw指令的数据冒险
//lw指令的数据冒险是由于lw指令的执行需要用到前一条指令的结果
//已经在Hazarddetector模块中处理了
module BrForwarding(
    input wire RegWrite_ex,
    input wire [4:0] rdAddr_ex,
    input wire [4:0] rs1Addr_id,
    input wire [4:0] rs2Addr_id,
    input wire RegWrite_mem,
    input wire [4:0] rdAddr_mem,
    input wire MemtoReg_mem,
    output wire [1:0] BrForwardA,
    output wire [1:0] BrForwardB
);
    reg [1:0] BrForwardA_reg,BrForwardB_reg;//转发信号寄存器
    //先处理BrForwardA
    always @(*) begin
        if(RegWrite_ex && rdAddr_ex != 5'b0 && rs1Addr_id==rdAddr_ex) begin//一级转发
            BrForwardA_reg = 2'b01;
        end
        else if(RegWrite_mem && rdAddr_mem != 5'b0 && rs1Addr_id==rdAddr_mem && rs1Addr_id!=rdAddr_ex) begin//二级转发
            if(MemtoReg_mem) begin//lw指令转发自MemDout_mem
                BrForwardA_reg = 2'b10;
            end
            else begin
                BrForwardA_reg = 2'b11;//其他指令转发自ALUResult_mem
            end
        end
        else begin
            BrForwardA_reg = 2'b00;//不转发
        end
    end

    //再处理BrForwardB
    always @(*) begin
        if(RegWrite_ex && rdAddr_ex != 5'b0 && rs2Addr_id==rdAddr_ex) begin//一级转发
            BrForwardB_reg = 2'b01;
        end
        else if(RegWrite_mem && rdAddr_mem != 5'b0 && rs2Addr_id==rdAddr_mem && rs2Addr_id!=rdAddr_ex) begin//二级转发
            if(MemtoReg_mem) begin//lw指令转发自MemDout_mem
                BrForwardB_reg = 2'b10;
            end
            else begin
                BrForwardB_reg = 2'b11;//其他指令转发自ALUResult_mem
            end
        end
        else begin
            BrForwardB_reg = 2'b00;//不转发
        end
    end

    assign BrForwardA = BrForwardA_reg;
    assign BrForwardB = BrForwardB_reg;
endmodule
    \end{lstlisting}
    \item 之后在ID模块加上BrForwarding模块的信号和连接。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image25.png}
    \end{figure}
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image26.png}
        \caption{ID模块增加BrForwarding模块的信号和连接}
    \end{figure}
    \item 最后简单修改CPU顶层模块。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image27.png}
        \caption{CPU顶层模块增加BrForwarding模块的信号和连接}
    \end{figure}
    \item 然后修改InstructionROM中的指令集进行测试
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/image28.png}
        \caption{InstructionROM中的指令集}
    \end{figure}

\end{itemize}

最终仿真测试结果如下，我们在InstructionROM中的d13d14指令加入了跳转的数据冲突以测试从EX阶段的ALU计算结果进行转发的正确性。
可以看到在1.3us到1.4us，d14指令的跳转条件在延时一个时钟周期后正确执行，说明数据冒险问题得到了解决。

同理，增加了lw和beq指令的数据冒险测试，经过仿真测试，数据冒险问题得到了解决。
    \begin{figure}[H]
        \centering
        \includegraphics[width=1\textwidth]{figures/fig/sim11.png}
        \caption{测试结果}
    \end{figure}

\Large 总结
\normalsize

虽然可以通过增加转发来解决lw+beq的数据冒险问题，但是这种方法存在很大的开销，如流水线暂停、额外的转发逻辑，过长的数据通路导致的延迟等。
因此，更好的方法是在软件上解决这种数据冒险问题，通过编译器优化和程序员手动调整来避免数据冒险，而不是在硬件层面直接处理。


%%----------- 参考文献 -------------------%%
%在reference.bib文件中填写参考文献，此处自动生成




\end{document}